{"version":3,"file":"podtable.esm.js","sources":["../src/podtable.js"],"sourcesContent":["function Podtable(tableEl, config = {}) {\r\n    let table = document.querySelector(tableEl)\r\n    let targetRow\r\n    let errorMessage\r\n\r\n    /**\r\n     * Perform an health check and if check fails we will throw an error\r\n     * but if its case empty tbody rows then we will assume no data \r\n     * and we then select the right element for target row\r\n     */\r\n    if (healthCheck(table) === false) {\r\n        throw new Error(errorMessage)\r\n    } else if (healthCheck(table) === -1) {\r\n        targetRow = document.querySelector(`${tableEl} thead tr`)\r\n    } else if (healthCheck(table)) {\r\n        targetRow = document.querySelector(`${tableEl} tbody tr`)\r\n    }\r\n\r\n    let tableContainer = document.createElement('div')\r\n    tableContainer.setAttribute('id', 'podtable-container')\r\n    table.parentNode.insertBefore(tableContainer, table)\r\n    tableContainer.appendChild(table)\r\n\r\n    let hiddenCells = []\r\n    let constIndex = [] \r\n    let keepCell = [0]\r\n    let oldWindowWidth = window.innerWidth\r\n    let _this = this\r\n\r\n    _this.current\r\n\r\n    setKeepCell(config)\r\n    setToggleCell(tableEl)\r\n    setCellIndex(tableEl)\r\n\r\n    render()\r\n    ayncRedraw(tableEl)\r\n\r\n    /**\r\n     * Performs an Health check on the target table\r\n     * @param {HTMLTableElement} table \r\n     * @returns Boolean\r\n     */\r\n    function healthCheck(table) {\r\n        if (table === null) {\r\n            errorMessage = 'Unable to access target HTMLTableElement'\r\n            return false\r\n        }\r\n\r\n        if (!(table instanceof HTMLTableElement)) {\r\n            errorMessage = 'Element is not a HTMLTableElement'\r\n            return false\r\n        }\r\n\r\n        if (table.tHead === null) {\r\n            errorMessage = 'Table should have only one THEAD'\r\n            return false\r\n        }\r\n\r\n        if (table.tBodies.length <= 0) {\r\n            errorMessage = 'Table should have only one TBODY'\r\n            return false\r\n        }\r\n\r\n        if (table.tBodies[0].rows.length <= 0) {\r\n            return -1\r\n        }\r\n\r\n        return true\r\n    }\r\n\r\n    /**\r\n     * Add css class to control cells\r\n     * @param {String} tableEl \r\n     */\r\n    function setToggleCell(tableEl) {\r\n        document.querySelector(`${tableEl} thead tr > th:last-child`).classList.add('main-toggle')\r\n        document.querySelectorAll(`${tableEl} tbody tr:not(tr.child) > td:last-child`).forEach(el => {\r\n            el.classList.add('toggle')\r\n        })\r\n    }\r\n\r\n    /**\r\n     * Add data attribute to elements to serve as cell index and we will\r\n     * Reverse cell index array to hide cells from the right and also make\r\n     * sure we reserve the toggle cell from being hidden along with others\r\n     * @param {String} tableElement\r\n     * @returns void \r\n     */\r\n    function setCellIndex(tableEl) {\r\n        let rows = document.querySelectorAll(`${tableEl} tr`)\r\n        let tempConst = []\r\n\r\n        for (let ci = 0; ci < targetRow.children.length; ci++) {\r\n            tempConst.push(ci)\r\n        }\r\n\r\n        for (let i = 0; i < rows.length; i++) {\r\n            let row = rows[i].children\r\n\r\n            for (let td = 0; td < row.length; td++) {\r\n                row[td].setAttribute('data-cell-index', row[td].cellIndex)\r\n            }\r\n        }\r\n\r\n        if (Object.prototype.hasOwnProperty.call(config, 'priority') &&\r\n            Array.isArray(config.priority) &&\r\n            config.priority.length > 0) {\r\n            \r\n            constIndex = Array.from(new Set(config.priority.concat(tempConst.reverse())))\r\n        } else {\r\n            constIndex = tempConst.reverse()\r\n        }\r\n\r\n        keepCell.push(tempConst.length - 1)\r\n    }\r\n\r\n    /**\r\n     * Merge config option with the existing keep cell array\r\n     * @param {Object} config \r\n     */\r\n    function setKeepCell(config) {\r\n        if(Object.prototype.hasOwnProperty.call(config, 'keepCell')) {\r\n            if (! Array.isArray(config.keepCell)) {\r\n                throw TypeError('keep cell must be of type array') \r\n            } else {\r\n                keepCell = [...keepCell, ...config.keepCell]\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create tr element and append cell column data\r\n     * @param {HTMLCollection} cells \r\n     * @returns Element Node\r\n     */\r\n    function childRow (cells) {\r\n        let tr = document.createElement('tr')\r\n        let gridTD = document.createElement('td')\r\n        let gridRow = document.createElement('div')\r\n        \r\n        gridTD.colSpan = constIndex.length\r\n        gridRow.classList.add('child-grid-row')\r\n        tr.classList.add('child')\r\n    \r\n        for (let i = 0; i < cells.length; i++) {\r\n            gridRow.append(cells[i])\r\n        }\r\n        \r\n        gridTD.append(gridRow)\r\n        tr.append(gridTD)\r\n    \r\n        return tr\r\n    }\r\n\r\n    /**\r\n     * Create grid column div Element to append to child row\r\n     * @param {el} el\r\n     * @returns Element Node\r\n     */\r\n    function gridCol(el) {\r\n        let gridCol = document.createElement('div')\r\n        gridCol.classList.add('child-grid-col')\r\n    \r\n        let dataColName = document.createElement('div')\r\n        let dataColDesc = document.createElement('div')\r\n        dataColName.innerHTML = el.dataset.gridColname\r\n        dataColDesc.innerHTML = el.innerHTML\r\n    \r\n        gridCol.append(dataColName)\r\n        gridCol.append(dataColDesc)\r\n        \r\n        return gridCol\r\n    }\r\n\r\n    /**\r\n     * Toggle single child row and calculate hidden element for the row \r\n     * @param {event} event\r\n     */\r\n    function toggle(e) {\r\n        if (hiddenCells.length <= 0) { return }\r\n        \r\n        let parent = e.target.parentElement\r\n\r\n        if(parent.classList.contains('has-child')) {\r\n            parent.classList.remove('has-child')\r\n            parent.nextElementSibling.remove()\r\n        } else {\r\n            parent.classList.add('has-child')\r\n            let isHidden = []\r\n            for (let i = 0; i < parent.cells.length; i++) {\r\n                if (parent.cells[i].classList.contains('hidden')) {\r\n                    isHidden.push(gridCol(parent.cells[i]))\r\n                }\r\n            }\r\n\r\n            parent.parentNode.insertBefore(childRow(isHidden), parent.nextSibling);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handles toggle all child rows event by checking which rows \r\n     * has child to close and which rows has no child to open\r\n     * @param {event} event\r\n     */\r\n    function toggleAll(e) {\r\n        if (hiddenCells.length <= 0) { return }\r\n\r\n        let toggleEls = document.querySelectorAll('.toggle')\r\n        let toggler = e.currentTarget\r\n\r\n        if(toggler.classList.contains('expanded')) {\r\n            for (let i = 0; i < toggleEls.length; i++) {\r\n                let togsParent = toggleEls[i].parentElement\r\n                if (togsParent.classList.contains('has-child')) {\r\n                    toggleEls[i].click()\r\n                }\r\n            }\r\n            toggler.classList.remove('expanded')\r\n        } else {\r\n            for (let i = 0; i < toggleEls.length; i++) {\r\n                let togsParent = toggleEls[i].parentElement\r\n                if (! togsParent.classList.contains('has-child')) {\r\n                    toggleEls[i].click()\r\n                }\r\n            }\r\n            toggler.classList.add('expanded')\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds click Event listener to rows with css class of \r\n     * toggle and main-toggle so as to toggle child rows\r\n     */\r\n    function addToggleListener () {\r\n        let togElements = document.querySelectorAll('.toggle')\r\n        for (let i = 0; i < togElements.length; i++) {\r\n            togElements[i].addEventListener('click', (e) => {\r\n                toggle(e)\r\n            })\r\n        }\r\n\r\n        let mainToggle = document.querySelector('.main-toggle')\r\n        mainToggle.addEventListener('click', (e) => {\r\n            toggleAll(e)\r\n        })\r\n    }\r\n\r\n    /**\r\n     * Check if there are hidden elements ands determine when to show\r\n     * child row toggle button and also clean up unused css class.\r\n     */\r\n    function doTogglerScreen () {\r\n        if(hiddenCells.length > 0) {\r\n            table.classList.add('show-toggle')\r\n        } else {\r\n            document.querySelectorAll('.has-child').forEach(el => {\r\n                el.classList.remove('has-child')\r\n            })\r\n\r\n            table.classList.remove('show-toggle')\r\n            document.querySelector('.main-toggle').classList.remove('expanded')\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Check for open child rows to enable reactivity as window resizes\r\n     * then apply changes, item are remove and added every time window resize\r\n     * and its like this so as to get an updated data from the cells\r\n     * parent row child row are redrawn on each control toggel.\r\n     */\r\n    function childRowListener () {\r\n        let openChildRow = document.querySelectorAll('.child')\r\n        \r\n        if(openChildRow.length > 0) {\r\n            let openChildParent = []\r\n\r\n            for (let i = 0; i < openChildRow.length; i++) {\r\n                openChildParent.push(openChildRow[i].previousElementSibling)\r\n            }\r\n\r\n            // Iterate from parents elements down to child elements\r\n            for (let ix = 0; ix < openChildParent.length; ix++) {\r\n                let isHidden = []\r\n                \r\n                for (let el in openChildParent[ix].children) {\r\n                    if(typeof openChildParent[ix].children[el].classList !== 'undefined' && openChildParent[ix].children[el].classList.contains('hidden')) {\r\n                        isHidden.push(gridCol(openChildParent[ix].children[el]))\r\n                    }\r\n                }\r\n\r\n                // we will remove the existing child row and put another one with new data\r\n                // we also check if the hidden cells length > 0 before inserting a new child row\r\n                // so as to avoid empty child rows and orphaned child rows\r\n                openChildParent[ix].nextElementSibling.remove()\r\n                \r\n                if(hiddenCells.length > 0) {\r\n                    openChildParent[ix].after(childRow(isHidden))\r\n                }\r\n\r\n                doTogglerScreen()\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Hide the next vertical cells that falls into the maximum squishitude\r\n     * using index from the cells constant index array and we dispatch an event \r\n     * which will take in the currently hidden index for that particular viewport.\r\n     * @param {Number} index \r\n     */\r\n    function hideMain(index) {\r\n        hiddenCells.push(index)\r\n        \r\n        document.querySelectorAll(`[data-cell-index=\"${index}\"]`).forEach(el => {\r\n            el.classList.add('hidden')\r\n        })\r\n\r\n        eventDispatch(index)\r\n    }\r\n\r\n    /**\r\n     * Here we will check if the window resize is an increase or decrease \r\n     * and determine which column to show base on the maximum squishitude \r\n     * of cell rows and also all necessary listeners to enable reactivity. \r\n     * when window size increases and there are no hidden cells we will need \r\n     * to dispatch event as well that there are currently no hidden cells.\r\n     */\r\n    function resize() {\r\n        let newWindowWidth = window.innerWidth\r\n\r\n        if (newWindowWidth < oldWindowWidth) {\r\n            recalc()\r\n            // childRowListener()\r\n\r\n        } else if (newWindowWidth > oldWindowWidth) {\r\n            recalc()\r\n\r\n            if (hiddenCells.length <= 0) {\r\n                eventDispatch(-1)\r\n                childRowListener()\r\n            }\r\n        }    \r\n        oldWindowWidth = newWindowWidth           \r\n    }\r\n\r\n    /**\r\n     * Recalculate Cells thats needs to be hidden after flushing\r\n     */\r\n    function recalc() {\r\n        flush()\r\n        \r\n        for (let i = 0; i < constIndex.length; i++) {\r\n            if (targetRow.clientWidth > tableContainer.clientWidth) {\r\n                if (!hiddenCells.includes(constIndex[i])) {\r\n                    if (!keepCell.includes(constIndex[i])) {\r\n                        hideMain(constIndex[i])\r\n                        childRowListener()\r\n                    } \r\n                }\r\n            }\r\n        }\r\n        \r\n        doTogglerScreen()\r\n    }\r\n\r\n    /**\r\n     * Here we remove the hidden class and flush the hidden cells \r\n     * array so as to restart procedure for the current viewport.\r\n     */\r\n    function flush() {\r\n        for (let i = 0; i < hiddenCells.length; i++) {\r\n            document.querySelectorAll(`[data-cell-index=\"${hiddenCells[i]}\"]`).forEach(el => {\r\n                el.classList.remove('hidden')\r\n            })\r\n        }\r\n\r\n        hiddenCells = []\r\n    }\r\n\r\n    /**\r\n     * On page load calculate cells which  can fit into the current\r\n     * maximum squishitude: apply visibility, attach necessary listeners.\r\n     */\r\n    function mount() {\r\n        hiddenCells = []\r\n        let newWindowWidth = window.innerWidth\r\n        let ilength = constIndex.length\r\n        \r\n        for (let i = 0; i < ilength; i++) {\r\n\r\n            if (targetRow.clientWidth > tableContainer.clientWidth) {\r\n                if(! hiddenCells.includes(constIndex[i])) {\r\n                    if (!keepCell.includes(constIndex[i])) {\r\n                        hideMain(constIndex[i])\r\n                    } \r\n                }\r\n            }\r\n            oldWindowWidth = newWindowWidth \r\n        }\r\n        doTogglerScreen()\r\n    }\r\n\r\n\r\n    /**\r\n     * Initialize table process\r\n     */\r\n    function render() {\r\n        mount()\r\n        addToggleListener()\r\n        window.addEventListener('resize',  () => resize())\r\n    }\r\n\r\n    /**\r\n     * On body rows child list mutation essential row attributes and events\r\n     * will be lost hence the need to reset attriubtes and re attach necessary \r\n     * events listeners and also redispatch cells event but only the attached method\r\n     * @param {String} tableEl \r\n     */\r\n    function ayncRedraw(tableEl) {\r\n        let bodyNode = document.querySelector(`${tableEl} tbody`)\r\n\r\n        function doAttributes(node) {\r\n            node.lastElementChild.classList.add('toggle')\r\n            node.lastElementChild.addEventListener('click', (e) => toggle(e))\r\n\r\n            for (let i = 0; i < node.children.length; i++) {\r\n                node.children[i].setAttribute('data-cell-index', node.children[i].cellIndex)\r\n            }\r\n        }\r\n\r\n        const callback = (mutationList, observer) => {\r\n            for (const mutation of mutationList) {\r\n                if (mutation.type === 'childList' && mutation.addedNodes.length === 1) {\r\n                    if (mutation.addedNodes[0].tagName == 'TR' && !mutation.addedNodes[0].classList.contains('child')) {\r\n                        doAttributes(mutation.addedNodes[0])\r\n                        shouldPing()\r\n                    }\r\n                } else if (mutation.type === 'childList' && mutation.removedNodes.length === 1) {\r\n                    if (mutation.removedNodes[0].tagName == 'TR' &&\r\n                        !mutation.removedNodes[0].classList.contains('child') &&\r\n                        mutation.removedNodes[0].classList.contains('has-child')) {\r\n                        mutation.nextSibling.remove()\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (document.querySelector(`${tableEl} tbody`).rows.length <= 0) {\r\n                targetRow = document.querySelector(`${tableEl} thead tr`)\r\n            } else {\r\n                targetRow = document.querySelector(`${tableEl} tbody tr`)\r\n            }\r\n\r\n            flush()\r\n            mount()\r\n        }\r\n\r\n        const observer = new MutationObserver(callback)\r\n\r\n        observer.observe(bodyNode, { childList: true })\r\n    }\r\n\r\n    /**\r\n     * For every cells hidden this method will be called which check\r\n     * if events want to be received also attach hidden index to return object.\r\n     * @param {Number} index \r\n     */\r\n    function eventDispatch(index) {\r\n        _this.current = index\r\n\r\n        if (config.event) { shouldPing() }\r\n    }\r\n\r\n    /**\r\n     * Call the user attached method only if the event key is in the config \r\n     * object and it is set to true and we will  also wrap the function call \r\n     * in a try catch block to avoid code execution failure.\r\n     */\r\n    function shouldPing() {\r\n        if (config.event) {\r\n            try {\r\n                config.method(_this)\r\n            } catch (error) {\r\n                console.error(error)\r\n            }\r\n        }\r\n    }\r\n\r\n    if (config.event) { return _this }\r\n}\r\n\r\nexport default Podtable"],"names":["Podtable","tableEl","config","targetRow","errorMessage","table","document","querySelector","healthCheck","Error","tableContainer","createElement","setAttribute","parentNode","insertBefore","appendChild","hiddenCells","constIndex","keepCell","oldWindowWidth","window","innerWidth","_this","this","HTMLTableElement","tHead","tBodies","length","rows","childRow","cells","tr","gridTD","gridRow","colSpan","classList","add","i","append","gridCol","el","dataColName","dataColDesc","innerHTML","dataset","gridColname","toggle","e","parent","target","parentElement","contains","remove","nextElementSibling","isHidden","push","nextSibling","doTogglerScreen","querySelectorAll","forEach","childRowListener","openChildRow","openChildParent","previousElementSibling","ix","children","after","hideMain","index","eventDispatch","recalc","flush","clientWidth","includes","mount","newWindowWidth","ilength","current","event","shouldPing","method","error","console","Object","prototype","hasOwnProperty","call","Array","isArray","TypeError","setKeepCell","setToggleCell","tempConst","ci","row","td","cellIndex","priority","from","Set","concat","reverse","setCellIndex","togElements","addEventListener","toggleEls","toggler","currentTarget","click","toggleAll","addToggleListener","bodyNode","doAttributes","node","lastElementChild","MutationObserver","mutationList","observer","mutation","type","addedNodes","tagName","removedNodes","observe","childList","ayncRedraw"],"mappings":"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"}
{"version":3,"file":"podtable.esm.js","sources":["../src/podtable.js"],"sourcesContent":["function Podtable(tableEl, config = {}) {\r\n    let table = document.querySelector(tableEl);\r\n    let firstBodyRow = document.querySelector(`${tableEl} tbody tr`);\r\n\r\n    let tableContainer = document.createElement('div');\r\n    tableContainer.setAttribute('id', 'podtable-container')\r\n    table.parentNode.insertBefore(tableContainer, table)\r\n    tableContainer.appendChild(table)\r\n\r\n    let hiddenCells = [];\r\n    let constIndex = []; \r\n    let breakPoint = {};\r\n    let breakPointOffset = {}\r\n    let keepCell = [0];\r\n    let oldWindowWidth = window.innerWidth;\r\n    let _this = this;\r\n\r\n    _this.current;\r\n    _this.isCurrentShown = false;\r\n\r\n    setKeepCell(config)\r\n    setToggleCell(tableEl)\r\n    setCellIndex(tableEl)\r\n\r\n    render()\r\n    ayncRedraw(tableEl);\r\n\r\n    /**\r\n     * Add css class to control cells\r\n     * @param {String} tableEl \r\n     */\r\n    function setToggleCell(tableEl) {\r\n        document.querySelector(`${tableEl} thead tr > th:last-child`).classList.add('main-toggle');\r\n        document.querySelectorAll(`${tableEl} tbody tr:not(tr.child) > td:last-child`).forEach(el => {\r\n            el.classList.add('toggle');\r\n        })\r\n    }\r\n\r\n    /**\r\n     * Add data attribute to elements to serve as index \r\n     * Reverse cell index array to hide cells from the back\r\n     * and make sure the toggle cell is being kept\r\n     * @param {*String} tableEl\r\n     * @returns void \r\n     */\r\n    function setCellIndex(tableEl) {\r\n        let rows = document.querySelectorAll(`${tableEl} tr`);\r\n\r\n        for (let ci = 0; ci < firstBodyRow.children.length; ci++) {\r\n            constIndex.push(ci)\r\n        }\r\n\r\n        for (let i = 0; i < rows.length; i++) {\r\n            let row = rows[i].children;\r\n\r\n            for (let td = 0; td < row.length; td++) {\r\n                row[td].setAttribute('data-cell-index', row[td].cellIndex);\r\n            }\r\n        }\r\n\r\n        keepCell.push(constIndex.length - 1)\r\n        constIndex.reverse()\r\n    }\r\n\r\n    /**\r\n     * Merge config option with the existing keep cell array\r\n     * @param {*Object} config \r\n     */\r\n    function setKeepCell(config) {\r\n        if (config.hasOwnProperty('keepCell')) {\r\n            if (! Array.isArray(config.keepCell)) {\r\n                throw TypeError('keep cell must be of type array') \r\n            } else {\r\n                keepCell = [...keepCell, ...config.keepCell];\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create tr element and append cell column data\r\n     * @param {} cells \r\n     * @returns Element Node\r\n     */\r\n    function childRow (cells) {\r\n        let tr = document.createElement('tr');\r\n        let gridTD = document.createElement('td');\r\n        let gridRow = document.createElement('div');\r\n        \r\n        gridTD.colSpan = constIndex.length;\r\n        gridRow.classList.add('child-grid-row');\r\n        tr.classList.add('child');\r\n    \r\n        for (let i = 0; i < cells.length; i++) {\r\n            gridRow.append(cells[i])\r\n        }\r\n        \r\n        gridTD.append(gridRow)\r\n        tr.append(gridTD)\r\n    \r\n        return tr;\r\n    }\r\n\r\n    /**\r\n     * Create grid column div Element to append to child row\r\n     * @param {el} el\r\n     * @returns \r\n     */\r\n    function gridCol(el) {\r\n        let gridCol = document.createElement('div');\r\n        gridCol.classList.add('child-grid-col');\r\n    \r\n        let dataColName = document.createElement('div');\r\n        let dataColDesc = document.createElement('div');\r\n        dataColName.innerHTML = el.dataset.gridColname;\r\n        dataColDesc.innerHTML = el.innerHTML;\r\n    \r\n        gridCol.append(dataColName)\r\n        gridCol.append(dataColDesc);\r\n        \r\n        return gridCol;\r\n    }\r\n\r\n    /**\r\n     * Toggle single child row and calculate hidden element for the row \r\n     * @param {event} event\r\n     */\r\n    function toggle(e) {\r\n        let parent = e.target.parentElement;\r\n\r\n        if(parent.classList.contains('has-child')) {\r\n            parent.classList.remove('has-child');\r\n            parent.nextElementSibling.remove();\r\n        } else {\r\n            parent.classList.add('has-child');\r\n            let isHidden = [];\r\n            for (let el in parent.children) {\r\n                if(typeof parent.children[el].classList !== 'undefined' && parent.children[el].classList.contains('hidden')) {\r\n                    isHidden.push(gridCol(parent.children[el]))\r\n                }\r\n            }\r\n\r\n            parent.after(childRow(isHidden))\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handles toggle all child rows event by checking which rows \r\n     * has child to close and which rows has no child to open\r\n     * @param {event} event\r\n     */\r\n    function toggleAll(e) {\r\n        let toggleEls = document.querySelectorAll('.toggle');\r\n        let toggler = e.currentTarget;\r\n\r\n        if(toggler.classList.contains('expanded')) {\r\n            for (let i = 0; i < toggleEls.length; i++) {\r\n                let togsParent = toggleEls[i].parentElement;\r\n                if (togsParent.classList.contains('has-child')) {\r\n                    toggleEls[i].click();\r\n                }\r\n            }\r\n            toggler.classList.remove('expanded');\r\n        } else {\r\n            for (let i = 0; i < toggleEls.length; i++) {\r\n                let togsParent = toggleEls[i].parentElement;\r\n                if (! togsParent.classList.contains('has-child')) {\r\n                    toggleEls[i].click();\r\n                }\r\n            }\r\n            toggler.classList.add('expanded');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds click Event listener to rows with css class of \r\n     * toggle and main-toggle so as to toggle child rows\r\n     */\r\n    function addToggleListener () {\r\n        let togElements = document.querySelectorAll('.toggle');\r\n        for (let i = 0; i < togElements.length; i++) {\r\n            togElements[i].addEventListener('click', (e) => {\r\n                toggle(e)\r\n            });\r\n        }\r\n\r\n        let mainToggle = document.querySelector('.main-toggle');\r\n        mainToggle.addEventListener('click', (e) => {\r\n            toggleAll(e)\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Check if there are hidden elements ands determine when to show\r\n     * child row toggle button and also clean up unused css class.\r\n     */\r\n    function doTogglerScreen () {\r\n        if(hiddenCells.length > 0) {\r\n            table.classList.add('show-toggle')\r\n        } else {\r\n            document.querySelectorAll('.has-child').forEach(el => {\r\n                el.classList.remove('has-child');\r\n            })\r\n\r\n            table.classList.remove('show-toggle')\r\n            document.querySelector('.main-toggle').classList.remove('expanded');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Check for open child rows to enable reactivity as window resizes\r\n     * apply changes, item are remove and added and every time window resize\r\n     * hidden elements are redrawn on each toggle\r\n     */\r\n    function childRowListener () {\r\n        let openChildRow = document.querySelectorAll('.child');\r\n        \r\n        if(openChildRow.length > 0) {\r\n            let openChildParent = [];\r\n\r\n            for (let i = 0; i < openChildRow.length; i++) {\r\n                openChildParent.push(openChildRow[i].previousElementSibling)\r\n            }\r\n\r\n            // Iterate from parents elements down to child elements\r\n            for (let ix = 0; ix < openChildParent.length; ix++) {\r\n                let isHidden = [];\r\n                \r\n                for (let el in openChildParent[ix].children) {\r\n                    if(typeof openChildParent[ix].children[el].classList !== 'undefined' && openChildParent[ix].children[el].classList.contains('hidden')) {\r\n                        isHidden.push(gridCol(openChildParent[ix].children[el]))\r\n                    }\r\n                }\r\n\r\n                // we will remove the existing child row and put another one with new data\r\n                // we also check if the hidden cells length > 0 so as to avoid empty child rows\r\n                openChildParent[ix].nextElementSibling.remove();\r\n                \r\n                if(hiddenCells.length > 0) {\r\n                    openChildParent[ix].after(childRow(isHidden))\r\n                }\r\n\r\n                doTogglerScreen()\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Hide thw next vertical cells that falls into the maximum squishitude\r\n     * break point using index from the cells constant index and also set it\r\n     * own show break point including its own offset\r\n     * @constant constIndex[index]\r\n     * @param {Number} index \r\n     */\r\n    function hideMain(index, newWindowWidth) {\r\n        breakPointOffset[`breakOffset${index}`] = newWindowWidth - tableContainer.clientWidth -1;\r\n        breakPoint[`bp${index}`] = firstBodyRow.clientWidth;\r\n        hiddenCells.push(index);\r\n        \r\n        document.querySelectorAll(`[data-cell-index=\"${index}\"]`).forEach(el => {\r\n            el.classList.add('hidden');\r\n        })\r\n\r\n        // onhide dispatch event and send index\r\n        eventDispatch(false, index)\r\n    }\r\n\r\n    /**\r\n     * Show the next vertical cells that falls into the maximum squishitude\r\n     * break point using last cell index from the hiddenCells\r\n     * @param {Number} lastCellIndex \r\n     */\r\n    function showMain(lastCellIndex) {\r\n        document.querySelectorAll(`[data-cell-index=\"${lastCellIndex}\"]`).forEach(el => {\r\n            el.classList.remove('hidden');\r\n        })\r\n        \r\n        delete breakPoint[`bp${lastCellIndex}`];\r\n        delete breakPointOffset[`breakOffset${lastCellIndex}`];\r\n        hiddenCells.pop();\r\n\r\n        // onDisplay dispatch event and send index\r\n        eventDispatch(true, lastCellIndex)\r\n    }\r\n\r\n    /**\r\n     * Check if the window resize increases or decreases and determine\r\n     * which column to show base on the maximum squishitude of cell rows\r\n     * and call necessary listeners to enable reactivity\r\n     */\r\n     function resize() {\r\n        let newWindowWidth = window.innerWidth;\r\n        \r\n        if (newWindowWidth < oldWindowWidth) {\r\n\r\n            for (let i = 0; i < constIndex.length; i++) {\r\n\r\n                if (firstBodyRow.clientWidth > tableContainer.clientWidth) {\r\n                    if(! hiddenCells.includes(constIndex[i])) {\r\n                        if( ! keepCell.includes(constIndex[i])) {\r\n                            hideMain(constIndex[i], newWindowWidth)\r\n                            childRowListener()\r\n                        }\r\n                    }\r\n                }\r\n            } \r\n\r\n            doTogglerScreen()\r\n        } else if(newWindowWidth > oldWindowWidth) {\r\n\r\n            if (hiddenCells.length > 0) {\r\n                // cache\r\n                let len = hiddenCells.length; \r\n\r\n                for (let i = 0; i < len; i++) {\r\n                    let lastCellIndex = hiddenCells.slice(-1)[0];\r\n\r\n                    if(newWindowWidth - breakPointOffset[`breakOffset${lastCellIndex}`] >  breakPoint[`bp${lastCellIndex}`]) {\r\n                        showMain(lastCellIndex)\r\n                        childRowListener()\r\n                    }\r\n                }\r\n                doTogglerScreen()\r\n            }\r\n        }    \r\n        oldWindowWidth = newWindowWidth;           \r\n    }\r\n\r\n    /**\r\n     * Dom mounted|window load calc and do visiibility including\r\n     * necessary listeners\r\n     */\r\n     function mount() {\r\n        hiddenCells = [];\r\n        let newWindowWidth = window.innerWidth;\r\n        let ilength = constIndex.length;\r\n        \r\n        for (let i = 0; i < ilength; i++) {\r\n\r\n            if (firstBodyRow.clientWidth > tableContainer.clientWidth) {\r\n                if(! hiddenCells.includes(constIndex[i])) {\r\n                    if (!keepCell.includes(constIndex[i])) {\r\n                        hideMain(constIndex[i], newWindowWidth)\r\n                    } \r\n                }\r\n            }\r\n            oldWindowWidth = newWindowWidth; \r\n        }\r\n        doTogglerScreen()\r\n    }\r\n\r\n\r\n    /**\r\n     * Initialize table process\r\n     */\r\n     function render() {\r\n        mount()\r\n        addToggleListener()\r\n        window.addEventListener('resize',  () => resize());\r\n    }\r\n\r\n    /**\r\n     * On dynamic node replace:patch essential row attributes will be lost\r\n     * hence the need to reset attriubtes and re attach necessary events listeners\r\n     * @param {*String} tableEl \r\n     */\r\n     function ayncRedraw(tableEl) {\r\n        let bodyNode = document.querySelector(`${tableEl} tbody`);\r\n\r\n        function doAttributes(node) {\r\n            node.lastElementChild.classList.add('toggle')\r\n            node.lastElementChild.addEventListener('click', (e) => toggle(e));\r\n\r\n            for (let i = 0; i < node.children.length; i++) {\r\n                node.children[i].setAttribute('data-cell-index', node.children[i].cellIndex);\r\n            }\r\n        }\r\n\r\n        function hideCells() {\r\n            for (let i = 0; i < hiddenCells.length; i++) {\r\n                document.querySelectorAll(`[data-cell-index=\"${hiddenCells[i]}\"]`).forEach(el => {\r\n                    el.classList.add('hidden');\r\n                })\r\n            }\r\n        }\r\n\r\n        const callback = (mutationList, observer) => {\r\n            for (const mutation of mutationList) {\r\n                if (mutation.type === 'childList' && mutation.addedNodes.length === 1) {\r\n                    if (mutation.addedNodes[0].tagName == 'TR' && !mutation.addedNodes[0].classList.contains('child')) {\r\n                        doAttributes(mutation.addedNodes[0])\r\n                    }\r\n                } else if (mutation.type === 'childList' && mutation.removedNodes.length === 1) {\r\n                    if (mutation.removedNodes[0].tagName == 'TR' &&\r\n                        !mutation.removedNodes[0].classList.contains('child') &&\r\n                        mutation.removedNodes[0].classList.contains('has-child')) {\r\n                            mutation.nextSibling.remove()\r\n                    }\r\n                }\r\n            }\r\n\r\n            hideCells()\r\n            firstBodyRow = document.querySelector(`${table.id} tbody tr`);\r\n        }\r\n\r\n        const observer = new MutationObserver(callback)\r\n        observer.observe(bodyNode, {childList: true })\r\n    }\r\n\r\n    /**\r\n     * If event is set true which means the user wants to perform an action \r\n     * for some cells define in the forcell() this methd dispatch the event\r\n     * @param {Boolean} isShown \r\n     * @param {Number} index \r\n     */\r\n    function eventDispatch(isShown, index) {\r\n        if (config.event) {\r\n            if (!Array.isArray(config.forCell) || config.forCell.length < 0) {\r\n                throw TypeError('forCell must be of type array and not empty')\r\n            }\r\n\r\n            _this.isCurrentShown = isShown;\r\n            _this.current = index;\r\n\r\n            if (config.forCell.includes(index)) {\r\n                config.method(_this)\r\n            }\r\n        }\r\n    }\r\n\r\n    if (config.event) {\r\n        return _this;\r\n    }\r\n}\r\n\r\nexport default Podtable"],"names":["Podtable","tableEl","config","table","document","querySelector","firstBodyRow","tableContainer","createElement","setAttribute","parentNode","insertBefore","appendChild","hiddenCells","constIndex","breakPoint","breakPointOffset","keepCell","oldWindowWidth","window","innerWidth","_this","this","childRow","cells","tr","gridTD","gridRow","colSpan","length","classList","add","i","append","gridCol","el","dataColName","dataColDesc","innerHTML","dataset","gridColname","toggle","e","parent","target","parentElement","contains","remove","nextElementSibling","isHidden","children","push","after","doTogglerScreen","querySelectorAll","forEach","childRowListener","openChildRow","openChildParent","previousElementSibling","ix","hideMain","index","newWindowWidth","clientWidth","eventDispatch","showMain","lastCellIndex","pop","isShown","event","Array","isArray","forCell","TypeError","isCurrentShown","current","includes","method","hasOwnProperty","setKeepCell","setToggleCell","rows","ci","row","td","cellIndex","reverse","setCellIndex","ilength","mount","togElements","addEventListener","toggleEls","toggler","currentTarget","click","toggleAll","addToggleListener","len","slice","resize","bodyNode","doAttributes","node","lastElementChild","MutationObserver","mutationList","observer","mutation","type","addedNodes","tagName","removedNodes","nextSibling","hideCells","id","observe","childList","ayncRedraw"],"mappings":"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"}
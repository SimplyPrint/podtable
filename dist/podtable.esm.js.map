{"version":3,"file":"podtable.esm.js","sources":["../src/podtable.js"],"sourcesContent":["function Podtable(tableEl, config = {}) {\r\n    let table = document.querySelector(tableEl)\r\n    let targetRow\r\n    let errorMessage\r\n\r\n    /**\r\n     * Perform an health check and if check fails we will throw an error\r\n     * but if its case empty tbody rows then we will assume no data \r\n     * and we then select the right element for target row\r\n     */\r\n    if (healthCheck(table) === false) {\r\n        throw new Error(errorMessage)\r\n    } else if (healthCheck(table) === -1) {\r\n        targetRow = document.querySelector(`${tableEl} thead tr`)\r\n    } else if (healthCheck(table)) {\r\n        targetRow = document.querySelector(`${tableEl} tbody tr`)\r\n    }\r\n\r\n    let tableContainer = document.createElement('div')\r\n    tableContainer.setAttribute('id', 'podtable-container')\r\n    table.parentNode.insertBefore(tableContainer, table)\r\n    tableContainer.appendChild(table)\r\n\r\n    let hiddenCells = []\r\n    let constIndex = [] \r\n    let keepCell = [0]\r\n\r\n    let _this = this\r\n    _this.current\r\n\r\n    setKeepCell(config)\r\n    setToggleCell(tableEl)\r\n    setCellIndex(tableEl)\r\n\r\n    render()\r\n    ayncRedraw(tableEl)\r\n\r\n    /**\r\n     * Performs an Health check on the target table\r\n     * @param {HTMLTableElement} table \r\n     * @returns Boolean\r\n     */\r\n    function healthCheck(table) {\r\n        if (table === null) {\r\n            errorMessage = 'Unable to access target HTMLTableElement'\r\n            return false\r\n        }\r\n\r\n        if (!(table instanceof HTMLTableElement)) {\r\n            errorMessage = 'Element is not a HTMLTableElement'\r\n            return false\r\n        }\r\n\r\n        if (table.tHead === null) {\r\n            errorMessage = 'Table should have only one THEAD'\r\n            return false\r\n        }\r\n\r\n        if (table.tBodies.length <= 0) {\r\n            errorMessage = 'Table should have only one TBODY'\r\n            return false\r\n        }\r\n\r\n        if (table.tBodies[0].rows.length <= 0) {\r\n            return -1\r\n        }\r\n\r\n        return true\r\n    }\r\n\r\n    /**\r\n     * Add css class to control cells\r\n     * @param {String} tableEl \r\n     */\r\n    function setToggleCell(tableEl) {\r\n        document.querySelector(`${tableEl} thead tr > th:last-child`).classList.add('main-toggle')\r\n        document.querySelectorAll(`${tableEl} tbody tr:not(tr.child) > td:last-child`).forEach(el => {\r\n            el.classList.add('toggle')\r\n        })\r\n    }\r\n\r\n    /**\r\n     * Add data attribute to elements to serve as cell index and we will\r\n     * Reverse cell index array to hide cells from the right and also make\r\n     * sure we reserve the toggle cell from being hidden along with others\r\n     * @param {String} tableElement\r\n     * @returns void \r\n     */\r\n    function setCellIndex(tableEl) {\r\n        let rows = document.querySelectorAll(`${tableEl} tr`)\r\n        let tempConst = []\r\n\r\n        for (let ci = 0; ci < targetRow.children.length; ci++) {\r\n            tempConst.push(ci)\r\n        }\r\n\r\n        if (Object.prototype.hasOwnProperty.call(config, 'priority') &&\r\n            Array.isArray(config.priority) &&\r\n            config.priority.length > 0) {\r\n            \r\n            constIndex = Array.from(new Set(config.priority.concat(tempConst.reverse())))\r\n        } else {\r\n            constIndex = tempConst.reverse()\r\n        }\r\n\r\n        keepCell.push(tempConst.length - 1)\r\n    }\r\n\r\n    /**\r\n     * Merge config option with the existing keep cell array\r\n     * @param {Object} config \r\n     */\r\n    function setKeepCell(config) {\r\n        if(Object.prototype.hasOwnProperty.call(config, 'keepCell')) {\r\n            if (! Array.isArray(config.keepCell)) {\r\n                throw TypeError('keep cell must be of type array') \r\n            } else {\r\n                keepCell = [...keepCell, ...config.keepCell]\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create tr element and append cell column data\r\n     * @param {HTMLCollection} cells \r\n     * @returns Element Node\r\n     */\r\n    function childRow (cells) {\r\n        let tr = document.createElement('tr')\r\n        let gridTD = document.createElement('td')\r\n        let gridRow = document.createElement('div')\r\n        \r\n        gridTD.colSpan = constIndex.length\r\n        gridRow.classList.add('child-grid-row')\r\n        tr.classList.add('child')\r\n    \r\n        for (let i = 0; i < cells.length; i++) {\r\n            gridRow.append(cells[i])\r\n        }\r\n        \r\n        gridTD.append(gridRow)\r\n        tr.append(gridTD)\r\n    \r\n        return tr\r\n    }\r\n\r\n    /**\r\n     * Create grid column div Element to append to child row\r\n     * @param {el} el\r\n     * @returns Element Node\r\n     */\r\n    function gridCol(el) {\r\n        let gridCol = document.createElement('div')\r\n        gridCol.classList.add('child-grid-col')\r\n    \r\n        let dataColName = document.createElement('div')\r\n        let dataColDesc = document.createElement('div')\r\n        dataColName.innerHTML = table.tHead.rows[0].cells[el.cellIndex].innerHTML\r\n        dataColDesc.innerHTML = el.innerHTML\r\n    \r\n        gridCol.append(dataColName)\r\n        gridCol.append(dataColDesc)\r\n        \r\n        return gridCol\r\n    }\r\n\r\n    /**\r\n     * Toggle single child row and calculate hidden element for the row \r\n     * @param {event} event\r\n     */\r\n    function toggle(e) {\r\n        if (hiddenCells.length <= 0) { return }\r\n        \r\n        let parent = e.target.parentElement\r\n\r\n        if(parent.classList.contains('has-child')) {\r\n            parent.classList.remove('has-child')\r\n            parent.nextElementSibling.remove()\r\n        } else {\r\n            parent.classList.add('has-child')\r\n            let isHidden = []\r\n            for (let i = 0; i < parent.cells.length; i++) {\r\n                if (parent.cells[i].classList.contains('hidden')) {\r\n                    isHidden.push(gridCol(parent.cells[i]))\r\n                }\r\n            }\r\n\r\n            parent.parentNode.insertBefore(childRow(isHidden), parent.nextSibling)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handles toggle all child rows event by checking which rows \r\n     * has child to close and which rows has no child to open\r\n     * @param {event} event\r\n     */\r\n    function toggleAll(e) {\r\n        if (hiddenCells.length <= 0) { return }\r\n\r\n        let toggleEls = document.querySelectorAll('.toggle')\r\n        let toggler = e.currentTarget\r\n\r\n        if(toggler.classList.contains('expanded')) {\r\n            for (let i = 0; i < toggleEls.length; i++) {\r\n                let togsParent = toggleEls[i].parentElement\r\n                if (togsParent.classList.contains('has-child')) {\r\n                    toggleEls[i].click()\r\n                }\r\n            }\r\n            toggler.classList.remove('expanded')\r\n        } else {\r\n            for (let i = 0; i < toggleEls.length; i++) {\r\n                let togsParent = toggleEls[i].parentElement\r\n                if (! togsParent.classList.contains('has-child')) {\r\n                    toggleEls[i].click()\r\n                }\r\n            }\r\n            toggler.classList.add('expanded')\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds click Event listener to rows with css class of \r\n     * toggle and main-toggle so as to toggle child rows\r\n     */\r\n    function addToggleListener () {\r\n        let togElements = document.querySelectorAll('.toggle')\r\n        for (let i = 0; i < togElements.length; i++) {\r\n            togElements[i].addEventListener('click', (e) => {\r\n                toggle(e)\r\n            })\r\n        }\r\n\r\n        let mainToggle = document.querySelector('.main-toggle')\r\n        mainToggle.addEventListener('click', (e) => {\r\n            toggleAll(e)\r\n        })\r\n    }\r\n\r\n    /**\r\n     * Check if there are hidden elements ands determine when to show\r\n     * child row toggle button and also clean up unused css class.\r\n     */\r\n    function doTogglerScreen () {\r\n        if(hiddenCells.length > 0) {\r\n            table.classList.add('show-toggle')\r\n        } else {\r\n            document.querySelectorAll('.has-child').forEach(el => {\r\n                el.classList.remove('has-child')\r\n            })\r\n\r\n            table.classList.remove('show-toggle')\r\n            table.tHead.rows[0].cells[table.tHead.rows[0].cells.length - 1].classList.remove('expanded')\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Check for open child rows to enable reactivity as window resizes\r\n     * then apply changes, item are remove and added every time window resize\r\n     * and its like this so as to get an updated data from the cells\r\n     * parent row child row are redrawn on each control toggle.\r\n     */\r\n    function childRowListener () {\r\n        let openChildRow = document.querySelectorAll('.child')\r\n        \r\n        if(openChildRow.length > 0) {\r\n            let openChildParent = []\r\n\r\n            for (let i = 0; i < openChildRow.length; i++) {\r\n                openChildParent.push(openChildRow[i].previousElementSibling)\r\n            }\r\n\r\n            // Iterate from parents elements down to child elements\r\n            for (let p = 0; p < openChildParent.length; p++) {\r\n                let isHidden = []\r\n                \r\n                for (let cell of openChildParent[p].cells) {\r\n                    if (cell.classList.contains('hidden')) {\r\n                        isHidden.push(gridCol(cell))\r\n                    }\r\n                }\r\n\r\n                // we will remove the existing child row and put another one with new data\r\n                // we also check if the hidden cells length > 0 before inserting a new child row\r\n                // so as to avoid empty child rows and orphaned child rows\r\n                openChildParent[p].nextElementSibling.remove()\r\n                \r\n                if(hiddenCells.length > 0) {\r\n                    openChildParent[p].after(childRow(isHidden))\r\n                }\r\n\r\n                doTogglerScreen()\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Hide the next vertical cells that falls into the maximum squishitude\r\n     * using index from the cells constant index array and we dispatch an event \r\n     * which will take in the currently hidden index for that particular viewport.\r\n     * @param {Number} index \r\n     */\r\n    function hideMain(index, pt = table) {\r\n        hiddenCells.push(index)\r\n\r\n        for (let row of pt.rows) {\r\n            row.cells[index].classList.add('hidden')\r\n        }\r\n\r\n        eventDispatch(index)\r\n    }\r\n\r\n    /**\r\n     * Here we will check if the window resize is an increase or decrease \r\n     * and determine which column to show base on the maximum squishitude \r\n     * of cell rows and also all necessary listeners to enable reactivity. \r\n     * when window size increases and there are no hidden cells we will need \r\n     * to dispatch event as well that there are currently no hidden cells.\r\n     */\r\n    function resize() {\r\n        recalc()\r\n        if (hiddenCells.length <= 0) {\r\n            eventDispatch(-1)\r\n            childRowListener()\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Recalculate Cells thats needs to be hidden after flushing\r\n     */\r\n    function recalc() {\r\n        flush()\r\n        \r\n        for (let i = 0; i < constIndex.length; i++) {\r\n            if (targetRow.clientWidth > tableContainer.clientWidth) {\r\n                if (!hiddenCells.includes(constIndex[i])) {\r\n                    if (!keepCell.includes(constIndex[i])) {\r\n                        hideMain(constIndex[i])\r\n                        childRowListener()\r\n                    } \r\n                }\r\n            }\r\n        }\r\n        \r\n        doTogglerScreen()\r\n    }\r\n\r\n    /**\r\n     * Here we remove the hidden class and flush the hidden cells \r\n     * array so as to restart procedure for the current viewport.\r\n     */\r\n    function flush() {\r\n        for (let i = 0; i < hiddenCells.length; i++) {\r\n            for (let row of table.rows) {\r\n                row.cells[hiddenCells[i]].classList.remove('hidden')\r\n            }\r\n        }\r\n\r\n        hiddenCells = []\r\n    }\r\n\r\n    /**\r\n     * On page load calculate cells which  can fit into the current\r\n     * maximum squishitude: apply visibility, attach necessary listeners.\r\n     */\r\n    function mount() {\r\n        hiddenCells = []\r\n        let ilength = constIndex.length\r\n        \r\n        for (let i = 0; i < ilength; i++) {\r\n\r\n            if (targetRow.clientWidth > tableContainer.clientWidth) {\r\n                if(! hiddenCells.includes(constIndex[i])) {\r\n                    if (!keepCell.includes(constIndex[i])) {\r\n                        hideMain(constIndex[i])\r\n                    } \r\n                }\r\n            }\r\n        }\r\n        doTogglerScreen()\r\n    }\r\n\r\n\r\n    /**\r\n     * Initialize table process\r\n     */\r\n    function render() {\r\n        mount()\r\n        addToggleListener()\r\n        window.addEventListener('resize',  () => resize())\r\n    }\r\n\r\n    /**\r\n     * On body rows child list mutation essential row attributes and events\r\n     * will be lost hence the need to reset attriubtes and re attach necessary \r\n     * events listeners and also redispatch cells event but only the attached method\r\n     * @param {String} tableEl \r\n     */\r\n    function ayncRedraw(tableEl) {\r\n        let bodyNode = document.querySelector(`${tableEl} tbody`)\r\n\r\n        function doAttributes(node) {\r\n            node.lastElementChild.classList.add('toggle')\r\n            node.lastElementChild.addEventListener('click', (e) => toggle(e))\r\n        }\r\n\r\n        const callback = (mutationList) => {\r\n            for (const mutation of mutationList) {\r\n                if (mutation.type === 'childList' && mutation.addedNodes.length === 1) {\r\n                    if (mutation.addedNodes[0].tagName == 'TR' && !mutation.addedNodes[0].classList.contains('child')) {\r\n                        doAttributes(mutation.addedNodes[0])\r\n                        shouldPing()\r\n                    }\r\n                } else if (mutation.type === 'childList' && mutation.removedNodes.length === 1) {\r\n                    if (mutation.removedNodes[0].tagName == 'TR' &&\r\n                        !mutation.removedNodes[0].classList.contains('child') &&\r\n                        mutation.removedNodes[0].classList.contains('has-child')) {\r\n                        mutation.nextSibling.remove()\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (document.querySelector(`${tableEl} tbody`).rows.length <= 0) {\r\n                targetRow = document.querySelector(`${tableEl} thead tr`)\r\n            } else {\r\n                targetRow = document.querySelector(`${tableEl} tbody tr`)\r\n            }\r\n\r\n            flush()\r\n            mount()\r\n        }\r\n\r\n        const observer = new MutationObserver(callback)\r\n\r\n        observer.observe(bodyNode, { childList: true })\r\n    }\r\n\r\n    /**\r\n     * For every cells hidden this method will be called which check\r\n     * if events want to be received also attach hidden index to return object.\r\n     * @param {Number} index \r\n     */\r\n    function eventDispatch(index) {\r\n        _this.current = index\r\n\r\n        if (config.event) { shouldPing() }\r\n    }\r\n\r\n    /**\r\n     * Call the user attached method only if the event key is in the config \r\n     * object and it is set to true and we will  also wrap the function call \r\n     * in a try catch block to avoid code execution failure.\r\n     */\r\n    function shouldPing() {\r\n        if (config.event) {\r\n            try {\r\n                config.method(_this)\r\n            } catch (error) {\r\n                console.error(error)\r\n            }\r\n        }\r\n    }\r\n\r\n    if (config.event) { return _this }\r\n}\r\n\r\nexport default Podtable"],"names":["Podtable","tableEl","config","targetRow","errorMessage","table","document","querySelector","healthCheck","Error","tableContainer","createElement","setAttribute","parentNode","insertBefore","appendChild","hiddenCells","constIndex","keepCell","_this","this","HTMLTableElement","tHead","tBodies","length","rows","childRow","cells","tr","gridTD","gridRow","colSpan","classList","add","i","append","gridCol","el","dataColName","dataColDesc","innerHTML","cellIndex","toggle","e","parent","target","parentElement","contains","remove","nextElementSibling","isHidden","push","nextSibling","doTogglerScreen","querySelectorAll","forEach","childRowListener","openChildRow","openChildParent","previousElementSibling","p","cell","after","hideMain","index","pt","eventDispatch","flush","mount","ilength","clientWidth","includes","current","event","shouldPing","method","error","console","Object","prototype","hasOwnProperty","call","Array","isArray","TypeError","setKeepCell","setToggleCell","tempConst","ci","children","priority","from","Set","concat","reverse","setCellIndex","togElements","addEventListener","toggleEls","toggler","currentTarget","click","toggleAll","addToggleListener","window","recalc","bodyNode","MutationObserver","mutationList","mutation","type","addedNodes","tagName","node","lastElementChild","removedNodes","observe","childList","ayncRedraw"],"mappings":"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"}
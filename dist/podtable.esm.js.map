{"version":3,"file":"podtable.esm.js","sources":["../src/podtable.js"],"sourcesContent":["function Podtable(tableEl, config = {}) {\r\n    let table = document.querySelector(tableEl)\r\n    let firstBodyRow = document.querySelector(`${tableEl} tbody tr`)\r\n\r\n    let tableContainer = document.createElement('div')\r\n    tableContainer.setAttribute('id', 'podtable-container')\r\n    table.parentNode.insertBefore(tableContainer, table)\r\n    tableContainer.appendChild(table)\r\n\r\n    let hiddenCells = []\r\n    let constIndex = [] \r\n    let keepCell = [0]\r\n    let oldWindowWidth = window.innerWidth\r\n    let _this = this\r\n\r\n    _this.current\r\n\r\n    setKeepCell(config)\r\n    setToggleCell(tableEl)\r\n    setCellIndex(tableEl)\r\n\r\n    render()\r\n    ayncRedraw(tableEl)\r\n\r\n    /**\r\n     * Add css class to control cells\r\n     * @param {String} tableEl \r\n     */\r\n    function setToggleCell(tableEl) {\r\n        document.querySelector(`${tableEl} thead tr > th:last-child`).classList.add('main-toggle')\r\n        document.querySelectorAll(`${tableEl} tbody tr:not(tr.child) > td:last-child`).forEach(el => {\r\n            el.classList.add('toggle')\r\n        })\r\n    }\r\n\r\n    /**\r\n     * Add data attribute to elements to serve as cell index and we will\r\n     * Reverse cell index array to hide cells from the right and also make\r\n     * sure we reserve the toggle cell from being hidden along with others\r\n     * @param {String} tableElement\r\n     * @returns void \r\n     */\r\n    function setCellIndex(tableEl) {\r\n        let rows = document.querySelectorAll(`${tableEl} tr`)\r\n        let tempConst = []\r\n\r\n        for (let ci = 0; ci < firstBodyRow.children.length; ci++) {\r\n            tempConst.push(ci)\r\n        }\r\n\r\n        for (let i = 0; i < rows.length; i++) {\r\n            let row = rows[i].children\r\n\r\n            for (let td = 0; td < row.length; td++) {\r\n                row[td].setAttribute('data-cell-index', row[td].cellIndex)\r\n            }\r\n        }\r\n\r\n        if (Object.prototype.hasOwnProperty.call(config, 'priority') &&\r\n            Array.isArray(config.priority) &&\r\n            config.priority.length > 0) {\r\n            \r\n            constIndex = Array.from(new Set(config.priority.concat(tempConst.reverse())))\r\n        } else {\r\n            constIndex = tempConst.reverse()\r\n        }\r\n\r\n        keepCell.push(tempConst.length - 1)\r\n    }\r\n\r\n    /**\r\n     * Merge config option with the existing keep cell array\r\n     * @param {Object} config \r\n     */\r\n    function setKeepCell(config) {\r\n        if(Object.prototype.hasOwnProperty.call(config, 'keepCell')) {\r\n            if (! Array.isArray(config.keepCell)) {\r\n                throw TypeError('keep cell must be of type array') \r\n            } else {\r\n                keepCell = [...keepCell, ...config.keepCell]\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create tr element and append cell column data\r\n     * @param {} cells \r\n     * @returns Element Node\r\n     */\r\n    function childRow (cells) {\r\n        let tr = document.createElement('tr')\r\n        let gridTD = document.createElement('td')\r\n        let gridRow = document.createElement('div')\r\n        \r\n        gridTD.colSpan = constIndex.length\r\n        gridRow.classList.add('child-grid-row')\r\n        tr.classList.add('child')\r\n    \r\n        for (let i = 0; i < cells.length; i++) {\r\n            gridRow.append(cells[i])\r\n        }\r\n        \r\n        gridTD.append(gridRow)\r\n        tr.append(gridTD)\r\n    \r\n        return tr\r\n    }\r\n\r\n    /**\r\n     * Create grid column div Element to append to child row\r\n     * @param {el} el\r\n     * @returns \r\n     */\r\n    function gridCol(el) {\r\n        let gridCol = document.createElement('div')\r\n        gridCol.classList.add('child-grid-col')\r\n    \r\n        let dataColName = document.createElement('div')\r\n        let dataColDesc = document.createElement('div')\r\n        dataColName.innerHTML = el.dataset.gridColname\r\n        dataColDesc.innerHTML = el.innerHTML\r\n    \r\n        gridCol.append(dataColName)\r\n        gridCol.append(dataColDesc)\r\n        \r\n        return gridCol\r\n    }\r\n\r\n    /**\r\n     * Toggle single child row and calculate hidden element for the row \r\n     * @param {event} event\r\n     */\r\n    function toggle(e) {\r\n        let parent = e.target.parentElement\r\n\r\n        if(parent.classList.contains('has-child')) {\r\n            parent.classList.remove('has-child')\r\n            parent.nextElementSibling.remove()\r\n        } else {\r\n            parent.classList.add('has-child')\r\n            let isHidden = []\r\n            for (let el in parent.children) {\r\n                if(typeof parent.children[el].classList !== 'undefined' && parent.children[el].classList.contains('hidden')) {\r\n                    isHidden.push(gridCol(parent.children[el]))\r\n                }\r\n            }\r\n\r\n            parent.after(childRow(isHidden))\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handles toggle all child rows event by checking which rows \r\n     * has child to close and which rows has no child to open\r\n     * @param {event} event\r\n     */\r\n    function toggleAll(e) {\r\n        let toggleEls = document.querySelectorAll('.toggle')\r\n        let toggler = e.currentTarget\r\n\r\n        if(toggler.classList.contains('expanded')) {\r\n            for (let i = 0; i < toggleEls.length; i++) {\r\n                let togsParent = toggleEls[i].parentElement\r\n                if (togsParent.classList.contains('has-child')) {\r\n                    toggleEls[i].click()\r\n                }\r\n            }\r\n            toggler.classList.remove('expanded')\r\n        } else {\r\n            for (let i = 0; i < toggleEls.length; i++) {\r\n                let togsParent = toggleEls[i].parentElement\r\n                if (! togsParent.classList.contains('has-child')) {\r\n                    toggleEls[i].click()\r\n                }\r\n            }\r\n            toggler.classList.add('expanded')\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds click Event listener to rows with css class of \r\n     * toggle and main-toggle so as to toggle child rows\r\n     */\r\n    function addToggleListener () {\r\n        let togElements = document.querySelectorAll('.toggle')\r\n        for (let i = 0; i < togElements.length; i++) {\r\n            togElements[i].addEventListener('click', (e) => {\r\n                toggle(e)\r\n            })\r\n        }\r\n\r\n        let mainToggle = document.querySelector('.main-toggle')\r\n        mainToggle.addEventListener('click', (e) => {\r\n            toggleAll(e)\r\n        })\r\n    }\r\n\r\n    /**\r\n     * Check if there are hidden elements ands determine when to show\r\n     * child row toggle button and also clean up unused css class.\r\n     */\r\n    function doTogglerScreen () {\r\n        if(hiddenCells.length > 0) {\r\n            table.classList.add('show-toggle')\r\n        } else {\r\n            document.querySelectorAll('.has-child').forEach(el => {\r\n                el.classList.remove('has-child')\r\n            })\r\n\r\n            table.classList.remove('show-toggle')\r\n            document.querySelector('.main-toggle').classList.remove('expanded')\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Check for open child rows to enable reactivity as window resizes\r\n     * then apply changes, item are remove and added every time window resize\r\n     * and its like this so as to get an updated data from the cells\r\n     * parentrow child row are redrawn on each control toggel.\r\n     */\r\n    function childRowListener () {\r\n        let openChildRow = document.querySelectorAll('.child')\r\n        \r\n        if(openChildRow.length > 0) {\r\n            let openChildParent = []\r\n\r\n            for (let i = 0; i < openChildRow.length; i++) {\r\n                openChildParent.push(openChildRow[i].previousElementSibling)\r\n            }\r\n\r\n            // Iterate from parents elements down to child elements\r\n            for (let ix = 0; ix < openChildParent.length; ix++) {\r\n                let isHidden = []\r\n                \r\n                for (let el in openChildParent[ix].children) {\r\n                    if(typeof openChildParent[ix].children[el].classList !== 'undefined' && openChildParent[ix].children[el].classList.contains('hidden')) {\r\n                        isHidden.push(gridCol(openChildParent[ix].children[el]))\r\n                    }\r\n                }\r\n\r\n                // we will remove the existing child row and put another one with new data\r\n                // we also check if the hidden cells length > 0 so as to avoid empty child rows\r\n                openChildParent[ix].nextElementSibling.remove()\r\n                \r\n                if(hiddenCells.length > 0) {\r\n                    openChildParent[ix].after(childRow(isHidden))\r\n                }\r\n\r\n                doTogglerScreen()\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Hide the next vertical cells that falls into the maximum squishitude\r\n     * using index from the cells constant index array and we dispatch an event \r\n     * which will take in the currently hidden index for that particular viewport.\r\n     * @param {Number} index \r\n     */\r\n    function hideMain(index) {\r\n        hiddenCells.push(index)\r\n        \r\n        document.querySelectorAll(`[data-cell-index=\"${index}\"]`).forEach(el => {\r\n            el.classList.add('hidden')\r\n        })\r\n\r\n        eventDispatch(index)\r\n    }\r\n\r\n    /**\r\n     * Here we will check if the window resize is an increase or decrease \r\n     * and determine which column to show base on the maximum squishitude \r\n     * of cell rows and also all necessary listeners to enable reactivity. \r\n     * when window size increases and there are no hidden cells we will need \r\n     * to dispatch event as well that there are currently no hidden cells.\r\n     */\r\n    function resize() {\r\n        let newWindowWidth = window.innerWidth\r\n\r\n        if (newWindowWidth < oldWindowWidth) {\r\n            recalc()\r\n\r\n        } else if (newWindowWidth > oldWindowWidth) {\r\n            if (hiddenCells.length > 0) {\r\n                recalc()\r\n\r\n                if (hiddenCells.length <= 0) {\r\n                    eventDispatch(-1)\r\n                }\r\n            }\r\n        }    \r\n        oldWindowWidth = newWindowWidth           \r\n    }\r\n\r\n    /**\r\n     * Recalculate Cells thats needs to be hidden after flushing\r\n     */\r\n    function recalc() {\r\n        flush()\r\n        \r\n        for (let i = 0; i < constIndex.length; i++) {\r\n\r\n            if (firstBodyRow.clientWidth > tableContainer.clientWidth) {\r\n                if (!hiddenCells.includes(constIndex[i])) {\r\n                    if (!keepCell.includes(constIndex[i])) {\r\n                        hideMain(constIndex[i])\r\n                        childRowListener()\r\n                    } \r\n                }\r\n            }\r\n        }\r\n        \r\n        doTogglerScreen()\r\n    }\r\n\r\n    /**\r\n     * Here we remove the hidden class and flush the hidden cells \r\n     * array so as to restart procedure for the current viewport.\r\n     */\r\n    function flush() {\r\n        for (let i = 0; i < hiddenCells.length; i++) {\r\n            document.querySelectorAll(`[data-cell-index=\"${hiddenCells[i]}\"]`).forEach(el => {\r\n                el.classList.remove('hidden')\r\n            })\r\n        }\r\n\r\n        hiddenCells = []\r\n    }\r\n\r\n    /**\r\n     * On page load calculate cells which  can fit into the current\r\n     * maximum squishitude: apply visibility, attach necessary listeners.\r\n     */\r\n    function mount() {\r\n        hiddenCells = []\r\n        let newWindowWidth = window.innerWidth\r\n        let ilength = constIndex.length\r\n        \r\n        for (let i = 0; i < ilength; i++) {\r\n\r\n            if (firstBodyRow.clientWidth > tableContainer.clientWidth) {\r\n                if(! hiddenCells.includes(constIndex[i])) {\r\n                    if (!keepCell.includes(constIndex[i])) {\r\n                        hideMain(constIndex[i])\r\n                    } \r\n                }\r\n            }\r\n            oldWindowWidth = newWindowWidth \r\n        }\r\n        doTogglerScreen()\r\n    }\r\n\r\n\r\n    /**\r\n     * Initialize table process\r\n     */\r\n    function render() {\r\n        mount()\r\n        addToggleListener()\r\n        window.addEventListener('resize',  () => resize())\r\n    }\r\n\r\n    /**\r\n     * On body rows child list mutation essential row attributes and events\r\n     * will be lost hence the need to reset attriubtes and re attach necessary \r\n     * events listeners and also redispatch cells event but only the attached method\r\n     * @param {String} tableEl \r\n     */\r\n    function ayncRedraw(tableEl) {\r\n        let bodyNode = document.querySelector(`${tableEl} tbody`)\r\n\r\n        function doAttributes(node) {\r\n            node.lastElementChild.classList.add('toggle')\r\n            node.lastElementChild.addEventListener('click', (e) => toggle(e))\r\n\r\n            for (let i = 0; i < node.children.length; i++) {\r\n                node.children[i].setAttribute('data-cell-index', node.children[i].cellIndex)\r\n            }\r\n        }\r\n\r\n        function hideCells() {\r\n            for (let i = 0; i < hiddenCells.length; i++) {\r\n                document.querySelectorAll(`[data-cell-index=\"${hiddenCells[i]}\"]`).forEach(el => {\r\n                    el.classList.add('hidden')\r\n                })\r\n            }\r\n        }\r\n\r\n        const callback = (mutationList, observer) => {\r\n            for (const mutation of mutationList) {\r\n                if (mutation.type === 'childList' && mutation.addedNodes.length === 1) {\r\n                    if (mutation.addedNodes[0].tagName == 'TR' && !mutation.addedNodes[0].classList.contains('child')) {\r\n                        doAttributes(mutation.addedNodes[0])\r\n                        shouldPing()\r\n                    }\r\n                } else if (mutation.type === 'childList' && mutation.removedNodes.length === 1) {\r\n                    if (mutation.removedNodes[0].tagName == 'TR' &&\r\n                        !mutation.removedNodes[0].classList.contains('child') &&\r\n                        mutation.removedNodes[0].classList.contains('has-child')) {\r\n                        mutation.nextSibling.remove()\r\n                    }\r\n                }\r\n            }\r\n\r\n            hideCells()\r\n            firstBodyRow = document.querySelector(`${table.id} tbody tr`)\r\n        }\r\n\r\n        const observer = new MutationObserver(callback)\r\n        \r\n        observer.observe(bodyNode, {childList: true })\r\n    }\r\n\r\n    /**\r\n     * For every cells hidden this method will be called which check\r\n     * if events want to be received also attach hidden index to return object.\r\n     * @param {Number} index \r\n     */\r\n    function eventDispatch(index) {\r\n        _this.current = index\r\n\r\n        if (config.event) { shouldPing() }\r\n    }\r\n\r\n    /**\r\n     * Call the user attached method only if the event key is in the config \r\n     * object and it is set to true and we will  also wrap the function call \r\n     * in a try catch block to avoid code execution failure.\r\n     */\r\n    function shouldPing() {\r\n        if (config.event) {\r\n            try {\r\n                config.method(_this)\r\n            } catch (error) {\r\n                console.error(error)\r\n            }\r\n        }\r\n    }\r\n\r\n    if (config.event) { return _this }\r\n}\r\n\r\nexport default Podtable"],"names":["Podtable","tableEl","config","table","document","querySelector","firstBodyRow","tableContainer","createElement","setAttribute","parentNode","insertBefore","appendChild","hiddenCells","constIndex","keepCell","oldWindowWidth","window","innerWidth","_this","this","childRow","cells","tr","gridTD","gridRow","colSpan","length","classList","add","i","append","gridCol","el","dataColName","dataColDesc","innerHTML","dataset","gridColname","toggle","e","parent","target","parentElement","contains","remove","nextElementSibling","isHidden","children","push","after","doTogglerScreen","querySelectorAll","forEach","childRowListener","openChildRow","openChildParent","previousElementSibling","ix","hideMain","index","eventDispatch","recalc","flush","clientWidth","includes","current","event","shouldPing","method","error","console","Object","prototype","hasOwnProperty","call","Array","isArray","TypeError","setKeepCell","setToggleCell","rows","tempConst","ci","row","td","cellIndex","priority","from","Set","concat","reverse","setCellIndex","newWindowWidth","ilength","mount","togElements","addEventListener","toggleEls","toggler","currentTarget","click","toggleAll","addToggleListener","bodyNode","doAttributes","node","lastElementChild","MutationObserver","mutationList","observer","mutation","type","addedNodes","tagName","removedNodes","nextSibling","hideCells","id","observe","childList","ayncRedraw"],"mappings":"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"}
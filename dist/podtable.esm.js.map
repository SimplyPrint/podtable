{"version":3,"file":"podtable.esm.js","sources":["../src/podtable.js"],"sourcesContent":["function Podtable(tableEl, config = {}) {\r\n    let table = document.querySelector(tableEl)\r\n    let firstBodyRow = document.querySelector(`${tableEl} tbody tr`)\r\n\r\n    let tableContainer = document.createElement('div')\r\n    tableContainer.setAttribute('id', 'podtable-container')\r\n    table.parentNode.insertBefore(tableContainer, table)\r\n    tableContainer.appendChild(table)\r\n\r\n    let hiddenCells = []\r\n    let constIndex = [] \r\n    let keepCell = [0]\r\n    let oldWindowWidth = window.innerWidth\r\n    let _this = this\r\n\r\n    _this.current\r\n\r\n    setKeepCell(config)\r\n    setToggleCell(tableEl)\r\n    setCellIndex(tableEl)\r\n\r\n    render()\r\n    ayncRedraw(tableEl)\r\n\r\n    /**\r\n     * Add css class to control cells\r\n     * @param {String} tableEl \r\n     */\r\n    function setToggleCell(tableEl) {\r\n        document.querySelector(`${tableEl} thead tr > th:last-child`).classList.add('main-toggle')\r\n        document.querySelectorAll(`${tableEl} tbody tr:not(tr.child) > td:last-child`).forEach(el => {\r\n            el.classList.add('toggle')\r\n        })\r\n    }\r\n\r\n    /**\r\n     * Add data attribute to elements to serve as cell index and we will\r\n     * Reverse cell index array to hide cells from the right and also make\r\n     * sure we reserve the toggle cell from being hidden along with others\r\n     * @param {String} tableEl\r\n     * @returns void \r\n     */\r\n    function setCellIndex(tableEl) {\r\n        let rows = document.querySelectorAll(`${tableEl} tr`)\r\n        let tempConst = []\r\n\r\n        for (let ci = 0; ci < firstBodyRow.children.length; ci++) {\r\n            tempConst.push(ci)\r\n        }\r\n\r\n        for (let i = 0; i < rows.length; i++) {\r\n            let row = rows[i].children\r\n\r\n            for (let td = 0; td < row.length; td++) {\r\n                row[td].setAttribute('data-cell-index', row[td].cellIndex)\r\n            }\r\n        }\r\n\r\n        if (Object.prototype.hasOwnProperty.call(config, 'priority') &&\r\n            Array.isArray(config.priority) &&\r\n            config.priority.length > 0) {\r\n            \r\n            constIndex = Array.from(new Set(config.priority.concat(tempConst.reverse())))\r\n        } else {\r\n            constIndex = tempConst.reverse()\r\n        }\r\n\r\n        keepCell.push(tempConst.length - 1)\r\n    }\r\n\r\n    /**\r\n     * Merge config option with the existing keep cell array\r\n     * @param {Object} config \r\n     */\r\n    function setKeepCell(config) {\r\n        if(Object.prototype.hasOwnProperty.call(config, 'keepCell')) {\r\n            if (! Array.isArray(config.keepCell)) {\r\n                throw TypeError('keep cell must be of type array') \r\n            } else {\r\n                keepCell = [...keepCell, ...config.keepCell]\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create tr element and append cell column data\r\n     * @param {} cells \r\n     * @returns Element Node\r\n     */\r\n    function childRow (cells) {\r\n        let tr = document.createElement('tr')\r\n        let gridTD = document.createElement('td')\r\n        let gridRow = document.createElement('div')\r\n        \r\n        gridTD.colSpan = constIndex.length\r\n        gridRow.classList.add('child-grid-row')\r\n        tr.classList.add('child')\r\n    \r\n        for (let i = 0; i < cells.length; i++) {\r\n            gridRow.append(cells[i])\r\n        }\r\n        \r\n        gridTD.append(gridRow)\r\n        tr.append(gridTD)\r\n    \r\n        return tr\r\n    }\r\n\r\n    /**\r\n     * Create grid column div Element to append to child row\r\n     * @param {el} el\r\n     * @returns \r\n     */\r\n    function gridCol(el) {\r\n        let gridCol = document.createElement('div')\r\n        gridCol.classList.add('child-grid-col')\r\n    \r\n        let dataColName = document.createElement('div')\r\n        let dataColDesc = document.createElement('div')\r\n        dataColName.innerHTML = el.dataset.gridColname\r\n        dataColDesc.innerHTML = el.innerHTML\r\n    \r\n        gridCol.append(dataColName)\r\n        gridCol.append(dataColDesc)\r\n        \r\n        return gridCol\r\n    }\r\n\r\n    /**\r\n     * Toggle single child row and calculate hidden element for the row \r\n     * @param {event} event\r\n     */\r\n    function toggle(e) {\r\n        let parent = e.target.parentElement\r\n\r\n        if(parent.classList.contains('has-child')) {\r\n            parent.classList.remove('has-child')\r\n            parent.nextElementSibling.remove()\r\n        } else {\r\n            parent.classList.add('has-child')\r\n            let isHidden = []\r\n            for (let el in parent.children) {\r\n                if(typeof parent.children[el].classList !== 'undefined' && parent.children[el].classList.contains('hidden')) {\r\n                    isHidden.push(gridCol(parent.children[el]))\r\n                }\r\n            }\r\n\r\n            parent.after(childRow(isHidden))\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handles toggle all child rows event by checking which rows \r\n     * has child to close and which rows has no child to open\r\n     * @param {event} event\r\n     */\r\n    function toggleAll(e) {\r\n        let toggleEls = document.querySelectorAll('.toggle')\r\n        let toggler = e.currentTarget\r\n\r\n        if(toggler.classList.contains('expanded')) {\r\n            for (let i = 0; i < toggleEls.length; i++) {\r\n                let togsParent = toggleEls[i].parentElement\r\n                if (togsParent.classList.contains('has-child')) {\r\n                    toggleEls[i].click()\r\n                }\r\n            }\r\n            toggler.classList.remove('expanded')\r\n        } else {\r\n            for (let i = 0; i < toggleEls.length; i++) {\r\n                let togsParent = toggleEls[i].parentElement\r\n                if (! togsParent.classList.contains('has-child')) {\r\n                    toggleEls[i].click()\r\n                }\r\n            }\r\n            toggler.classList.add('expanded')\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds click Event listener to rows with css class of \r\n     * toggle and main-toggle so as to toggle child rows\r\n     */\r\n    function addToggleListener () {\r\n        let togElements = document.querySelectorAll('.toggle')\r\n        for (let i = 0; i < togElements.length; i++) {\r\n            togElements[i].addEventListener('click', (e) => {\r\n                toggle(e)\r\n            })\r\n        }\r\n\r\n        let mainToggle = document.querySelector('.main-toggle')\r\n        mainToggle.addEventListener('click', (e) => {\r\n            toggleAll(e)\r\n        })\r\n    }\r\n\r\n    /**\r\n     * Check if there are hidden elements ands determine when to show\r\n     * child row toggle button and also clean up unused css class.\r\n     */\r\n    function doTogglerScreen () {\r\n        if(hiddenCells.length > 0) {\r\n            table.classList.add('show-toggle')\r\n        } else {\r\n            document.querySelectorAll('.has-child').forEach(el => {\r\n                el.classList.remove('has-child')\r\n            })\r\n\r\n            table.classList.remove('show-toggle')\r\n            document.querySelector('.main-toggle').classList.remove('expanded')\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Check for open child rows to enable reactivity as window resizes\r\n     * apply changes, item are remove and added and every time window resize\r\n     * parent child row are redrawn on each toggle\r\n     */\r\n    function childRowListener () {\r\n        let openChildRow = document.querySelectorAll('.child')\r\n        \r\n        if(openChildRow.length > 0) {\r\n            let openChildParent = []\r\n\r\n            for (let i = 0; i < openChildRow.length; i++) {\r\n                openChildParent.push(openChildRow[i].previousElementSibling)\r\n            }\r\n\r\n            // Iterate from parents elements down to child elements\r\n            for (let ix = 0; ix < openChildParent.length; ix++) {\r\n                let isHidden = []\r\n                \r\n                for (let el in openChildParent[ix].children) {\r\n                    if(typeof openChildParent[ix].children[el].classList !== 'undefined' && openChildParent[ix].children[el].classList.contains('hidden')) {\r\n                        isHidden.push(gridCol(openChildParent[ix].children[el]))\r\n                    }\r\n                }\r\n\r\n                // we will remove the existing child row and put another one with new data\r\n                // we also check if the hidden cells length > 0 so as to avoid empty child rows\r\n                openChildParent[ix].nextElementSibling.remove()\r\n                \r\n                if(hiddenCells.length > 0) {\r\n                    openChildParent[ix].after(childRow(isHidden))\r\n                }\r\n\r\n                doTogglerScreen()\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Hide the next vertical cells that falls into the maximum squishitude\r\n     * using index from the cells constant index.\r\n     * @param {Number} index \r\n     */\r\n    function hideMain(index) {\r\n        hiddenCells.push(index)\r\n        \r\n        document.querySelectorAll(`[data-cell-index=\"${index}\"]`).forEach(el => {\r\n            el.classList.add('hidden')\r\n        })\r\n\r\n        // onhide dispatch event and send index\r\n        eventDispatch(index)\r\n    }\r\n\r\n    /**\r\n     * Check if the window resize increases or decreases and determine\r\n     * which column to show base on the maximum squishitude of cell rows\r\n     * and call necessary listeners to enable reactivity\r\n     */\r\n    function resize() {\r\n        let newWindowWidth = window.innerWidth\r\n\r\n        if (newWindowWidth < oldWindowWidth) {\r\n            recalc(newWindowWidth)\r\n\r\n        } else if (newWindowWidth > oldWindowWidth) {\r\n            if (hiddenCells.length > 0) {\r\n\r\n                recalc(newWindowWidth)\r\n            }\r\n        }    \r\n        oldWindowWidth = newWindowWidth           \r\n    }\r\n\r\n    /**\r\n     * Recalculate Cells thats needs to be hidden after flushing\r\n     * @param {newWindowWidth} newWindowWidth \r\n     */\r\n    function recalc(newWindowWidth) {\r\n        flush()\r\n\r\n        let ilength = constIndex.length\r\n        \r\n        for (let i = 0; i < ilength; i++) {\r\n\r\n            if (firstBodyRow.clientWidth > tableContainer.clientWidth) {\r\n                if (!hiddenCells.includes(constIndex[i])) {\r\n                    if (!keepCell.includes(constIndex[i])) {\r\n                        hideMain(constIndex[i])\r\n                        childRowListener()\r\n                    } \r\n                }\r\n            }\r\n        }\r\n        doTogglerScreen()\r\n    }\r\n\r\n    function flush() {\r\n        for (let i = 0; i < hiddenCells.length; i++) {\r\n            document.querySelectorAll(`[data-cell-index=\"${hiddenCells[i]}\"]`).forEach(el => {\r\n                el.classList.remove('hidden')\r\n            })\r\n        }\r\n\r\n        hiddenCells = []\r\n    }\r\n\r\n    /**\r\n     * Dom mounted|window load calc and do visiibility including\r\n     * necessary listeners\r\n     */\r\n    function mount() {\r\n        hiddenCells = []\r\n        let newWindowWidth = window.innerWidth\r\n        let ilength = constIndex.length\r\n        \r\n        for (let i = 0; i < ilength; i++) {\r\n\r\n            if (firstBodyRow.clientWidth > tableContainer.clientWidth) {\r\n                if(! hiddenCells.includes(constIndex[i])) {\r\n                    if (!keepCell.includes(constIndex[i])) {\r\n                        hideMain(constIndex[i])\r\n                    } \r\n                }\r\n            }\r\n            oldWindowWidth = newWindowWidth \r\n        }\r\n        doTogglerScreen()\r\n    }\r\n\r\n\r\n    /**\r\n     * Initialize table process\r\n     */\r\n    function render() {\r\n        mount()\r\n        addToggleListener()\r\n        window.addEventListener('resize',  () => resize())\r\n    }\r\n\r\n    /**\r\n     * On dynamic node replace:patch essential row attributes will be lost\r\n     * hence the need to reset attriubtes and re attach necessary events listeners\r\n     * Also redispatch events but only the attached method\r\n     * @param {String} tableEl \r\n     */\r\n    function ayncRedraw(tableEl) {\r\n        let bodyNode = document.querySelector(`${tableEl} tbody`)\r\n\r\n        function doAttributes(node) {\r\n            node.lastElementChild.classList.add('toggle')\r\n            node.lastElementChild.addEventListener('click', (e) => toggle(e))\r\n\r\n            for (let i = 0; i < node.children.length; i++) {\r\n                node.children[i].setAttribute('data-cell-index', node.children[i].cellIndex)\r\n            }\r\n        }\r\n\r\n        function hideCells() {\r\n            for (let i = 0; i < hiddenCells.length; i++) {\r\n                document.querySelectorAll(`[data-cell-index=\"${hiddenCells[i]}\"]`).forEach(el => {\r\n                    el.classList.add('hidden')\r\n                })\r\n            }\r\n        }\r\n\r\n        const callback = (mutationList, observer) => {\r\n            for (const mutation of mutationList) {\r\n                if (mutation.type === 'childList' && mutation.addedNodes.length === 1) {\r\n                    if (mutation.addedNodes[0].tagName == 'TR' && !mutation.addedNodes[0].classList.contains('child')) {\r\n                        doAttributes(mutation.addedNodes[0])\r\n                        shouldPing()\r\n                    }\r\n                } else if (mutation.type === 'childList' && mutation.removedNodes.length === 1) {\r\n                    if (mutation.removedNodes[0].tagName == 'TR' &&\r\n                        !mutation.removedNodes[0].classList.contains('child') &&\r\n                        mutation.removedNodes[0].classList.contains('has-child')) {\r\n                        mutation.nextSibling.remove()\r\n                    }\r\n                }\r\n            }\r\n\r\n            hideCells()\r\n            firstBodyRow = document.querySelector(`${table.id} tbody tr`)\r\n        }\r\n\r\n        const observer = new MutationObserver(callback)\r\n        observer.observe(bodyNode, {childList: true })\r\n    }\r\n\r\n    /**\r\n     * If event is set true which means the user wants to perform an action \r\n     * for some cells define in the forcell() this methd dispatch the event\r\n     * @param {Number} index \r\n     */\r\n    function eventDispatch(index) {\r\n        if (config.event) {\r\n            if (!Array.isArray(config.forCell) || config.forCell.length < 0) {\r\n                throw TypeError('forCell must be of type array and not empty')\r\n            }\r\n\r\n            _this.current = index\r\n            shouldPing()\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Call the user attached method only if the event key is in the config \r\n     * object and it is set to true and we will  also wrap the function call \r\n     * in a try catch block to avoid code execution failure.\r\n     */\r\n    function shouldPing() {\r\n        if (config.event) {\r\n            try {\r\n                config.method(_this)\r\n            } catch (error) {\r\n                console.error(error);\r\n            }\r\n            \r\n        }\r\n    }\r\n\r\n    if (config.event) { return _this }\r\n}\r\n\r\nexport default Podtable"],"names":["Podtable","tableEl","config","table","document","querySelector","firstBodyRow","tableContainer","createElement","setAttribute","parentNode","insertBefore","appendChild","hiddenCells","constIndex","keepCell","oldWindowWidth","window","innerWidth","_this","this","childRow","cells","tr","gridTD","gridRow","colSpan","length","classList","add","i","append","gridCol","el","dataColName","dataColDesc","innerHTML","dataset","gridColname","toggle","e","parent","target","parentElement","contains","remove","nextElementSibling","isHidden","children","push","after","doTogglerScreen","querySelectorAll","forEach","childRowListener","openChildRow","openChildParent","previousElementSibling","ix","hideMain","index","event","Array","isArray","forCell","TypeError","current","shouldPing","eventDispatch","method","error","console","Object","prototype","hasOwnProperty","call","setKeepCell","setToggleCell","rows","tempConst","ci","row","td","cellIndex","priority","from","Set","concat","reverse","setCellIndex","newWindowWidth","ilength","clientWidth","includes","mount","togElements","addEventListener","toggleEls","toggler","currentTarget","click","toggleAll","addToggleListener","flush","recalc","bodyNode","doAttributes","node","lastElementChild","MutationObserver","mutationList","observer","mutation","type","addedNodes","tagName","removedNodes","nextSibling","hideCells","id","observe","childList","ayncRedraw"],"mappings":"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"}
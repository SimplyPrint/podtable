{"version":3,"file":"podtable.js","sources":["../src/podtable.js","../src/utils.js"],"sourcesContent":["import { watch, getTable } from './utils'\r\n\r\nfunction Podtable(tableEl, config = {}) {\r\n    /**\r\n     * default config options\r\n     * @type Object\r\n     */\r\n    let defaultOptions = {\r\n        keepCell: [],\r\n        priority: [],\r\n        method: null,\r\n        rowGroup: false\r\n    }\r\n\r\n    /**\r\n     * config options\r\n     */\r\n    let options = Object.assign({}, defaultOptions, config)\r\n\r\n    /**\r\n     * The associated table that podtable will render\r\n     * @returns HTMLTableElement\r\n     */\r\n    const table = getTable(tableEl)\r\n\r\n    /**\r\n     * This is the squishitude determinant row\r\n     * @type HTMLTableRowElement\r\n     */\r\n    let targetRow\r\n\r\n    /**\r\n     * A wrapper for the render table\r\n     * @returns HTMLElement\r\n     */\r\n    let tableContainer\r\n\r\n    /**\r\n     * Perform an health check on the passed table\r\n     * @returns void\r\n     */\r\n    healthCheck(table)\r\n\r\n    /**\r\n     * Cache container width after health check passed\r\n     */\r\n    let oldTableContainerWidth = tableContainer.clientWidth\r\n\r\n    /**\r\n     * This is store for currently hidden cells\r\n     * @type Array\r\n     */\r\n    let hiddenCells = []\r\n\r\n    /**\r\n     * Constant index of cells generated from target row\r\n     * @type Array\r\n     */\r\n    let constIndex = []\r\n\r\n    /**\r\n     * This is the podtable acessible state\r\n     */\r\n    let state = {\r\n        current: -1\r\n    }\r\n\r\n    /**\r\n     * Process the config options passed\r\n     * @returns void\r\n     */\r\n    processConfig()\r\n\r\n    /**\r\n     * Attach event listeners for control toggle\r\n     * @returns void\r\n     */\r\n    setToggleCell(table)\r\n\r\n    /**\r\n     * Renders the table for the first instance\r\n     * @returns void\r\n     */\r\n    render()\r\n\r\n    /**\r\n     * Starts a mutation observer\r\n     * @returns void\r\n     */\r\n    ayncRedraw(table)\r\n\r\n    /**\r\n     * Set rendering target row\r\n     * @param {HTMLTableElement} table \r\n     */\r\n    function setTargetRow(table) {\r\n        targetRow = table.tHead.rows[0]\r\n    }\r\n    \r\n    /**\r\n     * set the wrapper for podtable\r\n     */\r\n    function setWrapper() {\r\n        tableContainer = document.createElement('div')\r\n        tableContainer.setAttribute('id', 'podtable-container')\r\n        table.parentNode.insertBefore(tableContainer, table)\r\n        tableContainer.appendChild(table)\r\n    }\r\n\r\n    /**\r\n     * Perform health check and if it fail will throw an error\r\n     * @param {HTMLTableElement} table \r\n     */\r\n    function healthCheck(table) {\r\n        if (!(table instanceof HTMLTableElement) || table == null || table.tHead == null) {\r\n            throw new Error('Invalid HTMLTableElement')\r\n        }\r\n\r\n        if (table.tHead.rows.length <= 0 || table.tHead.rows[0].cells.length < 0) {\r\n            throw new Error('Invalid tHead HTMLTableRowElement')\r\n        }\r\n\r\n        setTargetRow(table)\r\n        setWrapper()\r\n    }\r\n\r\n    /**\r\n     * Sets the control cells CSS clasess\r\n     * @param {String} tableEl \r\n     */\r\n    function setToggleCell(table) {\r\n        for (let row of table.rows) {\r\n            if (row.parentElement.tagName.toUpperCase() == 'TBODY') {\r\n                if (! row.hasAttribute('data-ptr-ignore')) {\r\n                    row.lastElementChild.classList.add('toggle')\r\n                }\r\n            } else {\r\n                row.lastElementChild.classList.add('main-toggle')\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set cell hidden priority from the right\r\n     * Set indexes of cells to keep\r\n     */\r\n    function processConfig() {\r\n        let tempConst = []\r\n\r\n        for (let ci = 0; ci < targetRow.cells.length; ci++) {\r\n            tempConst.push(ci)\r\n        }\r\n\r\n        if (Array.isArray(options.priority) && options.priority.length > 0 ) {\r\n            constIndex = Array.from(new Set(options.priority.concat(tempConst.reverse())))\r\n        } else {\r\n            constIndex = tempConst.reverse()\r\n        }\r\n\r\n        if (! Array.isArray(options.keepCell)) {\r\n            throw TypeError('keepCell is not an array') \r\n        } else {\r\n            options.keepCell.push(0, tempConst.length - 1)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create HTMLTableRowElement & append cell column data\r\n     * @param {HTMLCollection} cells \r\n     * @returns HTMLTableRowElement\r\n     */\r\n    function childRow (cells) {\r\n        let tr = document.createElement('tr')\r\n        let gridTD = document.createElement('td')\r\n        let gridRow = document.createElement('div')\r\n        \r\n        gridTD.colSpan = constIndex.length\r\n        gridRow.classList.add('child-grid-row')\r\n        tr.classList.add('child')\r\n    \r\n        for (let i = 0; i < cells.length; i++) {\r\n            gridRow.append(cells[i])\r\n        }\r\n        \r\n        gridTD.append(gridRow)\r\n        tr.append(gridTD)\r\n    \r\n        return tr\r\n    }\r\n\r\n    /**\r\n     * Create HTMLElement to append to child row\r\n     * @param {HTMLTableCellElement} el\r\n     * @returns HTMLElement\r\n     */\r\n    function gridCol(el) {\r\n        let gridCol = document.createElement('div')\r\n        gridCol.classList.add('child-grid-col')\r\n    \r\n        let dataColName = document.createElement('div')\r\n        let dataColDesc = document.createElement('div')\r\n        dataColName.innerHTML = table.tHead.rows[0].cells[el.cellIndex].innerHTML\r\n        dataColDesc.innerHTML = el.innerHTML\r\n    \r\n        gridCol.append(dataColName)\r\n        gridCol.append(dataColDesc)\r\n        \r\n        return gridCol\r\n    }\r\n\r\n    /**\r\n     * Toggle single child row and calculate hidden element for the row \r\n     * @param {event} e\r\n     */\r\n    function toggle(e) {\r\n        if (hiddenCells.length <= 0) { return }\r\n        \r\n        let parent = e.currentTarget.parentElement\r\n\r\n        if(parent.classList.contains('has-child')) {\r\n            parent.classList.remove('has-child')\r\n            parent.nextElementSibling.remove()\r\n        } else {\r\n            parent.classList.add('has-child')\r\n            let isHidden = []\r\n            for (let i = 0; i < parent.cells.length; i++) {\r\n                if (parent.cells[i].classList.contains('hidden')) {\r\n                    isHidden.push(gridCol(parent.cells[i]))\r\n                }\r\n            }\r\n\r\n            parent.parentNode.insertBefore(childRow(isHidden), parent.nextSibling)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handles toggle all child rows event by checking which rows \r\n     * has child to close and which rows has no child to open\r\n     * @param {event} e\r\n     */\r\n    function toggleAll(e) {\r\n        if (hiddenCells.length <= 0) { return }\r\n\r\n        let toggleEls = document.querySelectorAll('.toggle')\r\n        let toggler = e.currentTarget\r\n\r\n        if(toggler.classList.contains('expanded')) {\r\n            for (let i = 0; i < toggleEls.length; i++) {\r\n                let togsParent = toggleEls[i].parentElement\r\n                if (togsParent.classList.contains('has-child')) {\r\n                    toggleEls[i].click()\r\n                }\r\n            }\r\n            \r\n            toggler.classList.remove('expanded')\r\n        } else {\r\n            for (let i = 0; i < toggleEls.length; i++) {\r\n                let togsParent = toggleEls[i].parentElement\r\n                if (! togsParent.classList.contains('has-child')) {\r\n                    toggleEls[i].click()\r\n                }\r\n            }\r\n\r\n            toggler.classList.add('expanded')\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds click Event listener to rows with css class of \r\n     * toggle and main-toggle so as to toggle child rows\r\n     */\r\n    function addToggleListener () {\r\n        let togElements = document.querySelectorAll('.toggle')\r\n        for (let i = 0; i < togElements.length; i++) {\r\n            togElements[i].addEventListener('click', (e) => {\r\n                toggle(e)\r\n            })\r\n        }\r\n\r\n        let mainToggle = document.querySelector('.main-toggle')\r\n        mainToggle.addEventListener('click', (e) => {\r\n            toggleAll(e)\r\n        })\r\n    }\r\n\r\n    /**\r\n     * Check if there are hidden elements ands determine when to show\r\n     * child row toggle button and also clean up unused css class.\r\n     */\r\n    function doTogglerScreen () {\r\n        if(hiddenCells.length > 0) {\r\n            table.classList.add('show-toggle')\r\n        } else {\r\n            document.querySelectorAll('.has-child').forEach(el => {\r\n                el.classList.remove('has-child')\r\n            })\r\n\r\n            table.classList.remove('show-toggle')\r\n            table.tHead.rows[0].cells[table.tHead.rows[0].cells.length - 1].classList.remove('expanded')\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Check for open child rows to enable reactivity as window resizes\r\n     * then apply changes, item are remove and added every time window resize\r\n     * and its like this so as to get an updated data from the cells\r\n     * child row are redrawn on each control toggle.\r\n     */\r\n    function childRowListener () {\r\n        let childRows = document.querySelectorAll('tr.child')\r\n        \r\n        if(childRows.length > 0) {\r\n            let parentRows = []\r\n\r\n            for (let row of childRows) {\r\n                parentRows.push(row.previousElementSibling)\r\n            }\r\n\r\n            // Iterate from parents elements down to child elements\r\n            for (let p = 0; p < parentRows.length; p++) {\r\n                let isHidden = []\r\n                \r\n                for (let cell of parentRows[p].cells) {\r\n                    if (cell.classList.contains('hidden')) {\r\n                        isHidden.push(gridCol(cell))\r\n                    }\r\n                }\r\n\r\n                // we will remove the existing child row and put another one with new data\r\n                // we also check if the hidden cells length > 0 before inserting a new child row\r\n                // so as to avoid empty child rows and orphaned child rows\r\n                parentRows[p].nextElementSibling.remove()\r\n                \r\n                if(hiddenCells.length > 0) {\r\n                    parentRows[p].after(childRow(isHidden))\r\n                }\r\n\r\n                doTogglerScreen()\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Hide cells that falls into maximum squishitude\r\n     * Dispatch event for the current hidden cells index\r\n     * @param {Number} index \r\n     */\r\n    function hideMain(index, pt = table) {\r\n        hiddenCells.push(index)\r\n\r\n        for (let row of pt.rows) {            \r\n            if (!row.classList.contains('child') && !row.hasAttribute('data-ptr-ignore')) {\r\n                row.cells[index].classList.add('hidden')\r\n            }\r\n        }\r\n\r\n        eventDispatch(index)\r\n    }\r\n\r\n    /**\r\n     * Here we remove the hidden class and flush the hidden cells \r\n     * array so as to restart procedure for the current viewport.\r\n     */\r\n    function flush() {\r\n        for (let i = 0; i < hiddenCells.length; i++) {\r\n            for (let row of table.rows) {\r\n                if (!row.classList.contains('child') && !row.hasAttribute('data-ptr-ignore')) {\r\n                    row.cells[hiddenCells[i]].classList.remove('hidden')\r\n                }\r\n            }\r\n        }\r\n\r\n        hiddenCells = []\r\n    }\r\n\r\n    /**\r\n     * Recalculate Cells thats needs to be hidden after flushing\r\n     */\r\n    function recalc() {\r\n        flush()\r\n        \r\n        for (let i = 0; i < constIndex.length; i++) {\r\n            if (targetRow.clientWidth > tableContainer.clientWidth) {\r\n                if (!hiddenCells.includes(constIndex[i])) {\r\n                    if (! options.keepCell.includes(constIndex[i])) {\r\n                        hideMain(constIndex[i])\r\n                        childRowListener()\r\n                    } \r\n                }\r\n            }\r\n        }\r\n        \r\n        doTogglerScreen()\r\n    }\r\n\r\n    /**\r\n     * This method recalculate which cells to hide or show and dispatch\r\n     * event with negative index to indicate there are no hiddenCells\r\n     */\r\n    function resize() {\r\n        recalc()\r\n        \r\n        if (hiddenCells.length <= 0) {\r\n            eventDispatch(-1)\r\n            childRowListener()\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * On mounted calculate cells which  can fit into the current\r\n     * maximum squishitude: apply visibility, attach listeners.\r\n     */\r\n    function mount() {\r\n        hiddenCells = []\r\n        let ilength = constIndex.length\r\n        \r\n        for (let i = 0; i < ilength; i++) {\r\n\r\n            if (targetRow.clientWidth > tableContainer.clientWidth) {\r\n                if(! hiddenCells.includes(constIndex[i])) {\r\n                    if (! options.keepCell.includes(constIndex[i])) {\r\n                        hideMain(constIndex[i])\r\n                    } \r\n                }\r\n            }\r\n        }\r\n        doTogglerScreen()\r\n    }\r\n\r\n    /**\r\n     * This is the resize counterpart for window resize event\r\n     * or element watcher event\r\n     * @see resize\r\n     */\r\n    function observeResize() {\r\n        recalc()\r\n        if (hiddenCells.length <= 0) {\r\n            eventDispatch(-1)\r\n            childRowListener()\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handles resize listener\r\n     */\r\n    function observed() {\r\n        let connected = false\r\n\r\n        try {\r\n            const observer = new ResizeObserver((entries) => {\r\n                if (entries[0].target.clientWidth !== oldTableContainerWidth) {\r\n                    observeResize()\r\n                }\r\n    \r\n                oldTableContainerWidth = entries[0].target.clientWidth\r\n            })\r\n\r\n            observer.observe(tableContainer)\r\n            connected = true\r\n        } catch (error) {\r\n            connected = false\r\n        }\r\n\r\n        return connected\r\n    }\r\n\r\n\r\n    /**\r\n     * Starts an observer at podtable instance and \r\n     * attach necessary listeners\r\n     */\r\n    function render() {\r\n        mount()\r\n        addToggleListener()\r\n\r\n        if (!observed()) {\r\n            try {\r\n                watch(tableContainer, resize).start()\r\n            } catch (err) {\r\n                window.addEventListener('resize',  () => resize()) \r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handles childList mutations by re-attaching attributes, \r\n     * events and dispatching events\r\n     * @param {HTMLTableElement} table \r\n     */\r\n    function ayncRedraw(table) {\r\n        function resetRow(node) {\r\n            if (! node.hasAttribute('data-ptr-ignore')) {\r\n                node.lastElementChild.classList.add('toggle')\r\n                node.lastElementChild.addEventListener('click', (e) => toggle(e))\r\n            }\r\n        }\r\n\r\n        const callback = (mutations) => {\r\n            for (const mutation of mutations) {\r\n                if (mutation.type == 'childList' && mutation.addedNodes.length == 1) {\r\n                    if (mutation.addedNodes[0].tagName.toUpperCase() == 'TBODY') {\r\n                        for (let node of mutation.addedNodes[0].children) {\r\n                            resetRow(node)\r\n                            shouldPing()\r\n                        }\r\n                    }\r\n\r\n                    if (mutation.addedNodes[0].tagName.toUpperCase() == 'TR' && !mutation.addedNodes[0].classList.contains('child')) {\r\n                        resetRow(mutation.addedNodes[0])\r\n                        shouldPing()\r\n                    }\r\n                } else if (mutation.type == 'childList' && mutation.removedNodes.length == 1) {\r\n                    if (mutation.removedNodes[0].tagName.toUpperCase() == 'TR' &&\r\n                        !mutation.removedNodes[0].classList.contains('child') &&\r\n                        mutation.removedNodes[0].classList.contains('has-child')) {\r\n                        mutation.nextSibling.remove()\r\n                    }\r\n                }\r\n            }\r\n\r\n            setTargetRow(table)\r\n            flush()\r\n            mount()\r\n        }\r\n\r\n        let observable = options.rowGroup ? table : table.tBodies[0]\r\n        const observer = new MutationObserver(callback)\r\n        observer.observe(observable, { childList: true })\r\n    }\r\n\r\n    /**\r\n     * Dispatch event for the current hidden cell index\r\n     * @param {Number} index \r\n     */\r\n    function eventDispatch(index) {\r\n        state.current = index\r\n\r\n        if (options.method) { shouldPing() }\r\n    }\r\n\r\n    /**\r\n     * Dispatchs event\r\n     */\r\n    function shouldPing() {\r\n        if (options.method) {\r\n            try {\r\n                options.method(state)\r\n            } catch (err) {\r\n                console.error(err)\r\n            }\r\n        }\r\n    }\r\n\r\n    if (options.method) { return state }\r\n}\r\n\r\nexport default Podtable","export function watch(element, fn) {\r\n    let _this = {}\r\n    let obj = document.createElement('object')\r\n\r\n    /**\r\n     * Event listener to the docs object\r\n     */\r\n    function resizeEvent () {\r\n        this.contentDocument.defaultView.addEventListener('resize', fn)\r\n    }\r\n\r\n    /**\r\n     * Attach event listener to object\r\n     */\r\n    _this.start = () => {\r\n        obj.classList.add('pt-object')\r\n        obj.type = 'text/html'\r\n        obj.data = 'about:blank'\r\n        obj.onload = resizeEvent\r\n        element.appendChild(obj)\r\n    }\r\n\r\n    /**\r\n     * dettach event listener and remove object\r\n     */\r\n    _this.stop = () => {\r\n        obj.contentDocument.defaultView.removeEventListener('resize', fn)\r\n        element.removeChild(obj)\r\n    }\r\n\r\n    return _this\r\n}\r\n\r\n/**\r\n * Returns the target table element\r\n * @param {String|HTMLTableElement} tableEl \r\n * @returns HTMLTableElement\r\n */\r\nexport function getTable(tableEl) {\r\n    if (typeof tableEl === 'string' || tableEl instanceof String) {\r\n        return document.querySelector(tableEl)\r\n    } else {\r\n        return tableEl\r\n    }\r\n}"],"names":["tableEl","config","targetRow","tableContainer","options","Object","assign","keepCell","priority","method","rowGroup","table","String","document","querySelector","getTable","HTMLTableElement","tHead","Error","rows","length","cells","setTargetRow","setWrapper","healthCheck","oldTableContainerWidth","clientWidth","hiddenCells","constIndex","state","current","createElement","setAttribute","parentNode","insertBefore","appendChild","childRow","tr","gridTD","gridRow","colSpan","classList","add","i","append","gridCol","el","dataColName","dataColDesc","innerHTML","cellIndex","toggle","e","parent","currentTarget","parentElement","contains","remove","nextElementSibling","isHidden","push","nextSibling","doTogglerScreen","querySelectorAll","forEach","childRowListener","childRows","parentRows","previousElementSibling","p","cell","after","hideMain","index","pt","row","hasAttribute","eventDispatch","flush","recalc","includes","resize","mount","ilength","shouldPing","err","console","error","tempConst","ci","Array","isArray","from","Set","concat","reverse","TypeError","processConfig","tagName","toUpperCase","lastElementChild","setToggleCell","togElements","addEventListener","toggleEls","toggler","click","toggleAll","addToggleListener","connected","ResizeObserver","entries","target","observe","observed","element","fn","_this","obj","resizeEvent","this","contentDocument","defaultView","start","type","data","onload","stop","removeEventListener","removeChild","watch","window","render","resetRow","node","observable","tBodies","MutationObserver","mutations","mutation","addedNodes","children","removedNodes","childList","ayncRedraw"],"mappings":"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"}
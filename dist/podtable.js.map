{"version":3,"file":"podtable.js","sources":["../src/podtable.js","../src/utils.js"],"sourcesContent":["import { watch, getTable } from './utils'\r\n\r\nfunction Podtable(tableEl, config = {}) {\r\n    /**\r\n     * default config options\r\n     * @type Object\r\n     */\r\n    let defaultOptions = {\r\n        keepCell: [],\r\n        priority: [],\r\n        method: null\r\n    }\r\n\r\n    /**\r\n     * config options\r\n     */\r\n    let options = Object.assign({}, defaultOptions, config)\r\n\r\n    /**\r\n     * The associated table that podtable will render\r\n     * @returns HTMLTableElement\r\n     */\r\n    const table = getTable(tableEl)\r\n\r\n    /**\r\n     * This is the squishitude determinant row\r\n     * @type HTMLTableRowElement\r\n     */\r\n    let targetRow\r\n\r\n    /**\r\n     * A wrapper for the render table\r\n     * @returns HTMLElement\r\n     */\r\n    let tableContainer\r\n\r\n    /**\r\n     * Perform an health check on the passed table\r\n     * @returns void\r\n     */\r\n    healthCheck(table)\r\n\r\n    /**\r\n     * Cache container width after health check passed\r\n     */\r\n    let oldTableContainerWidth = tableContainer.clientWidth\r\n\r\n    /**\r\n     * This is store for currently hidden cells\r\n     * @type Array\r\n     */\r\n    let hiddenCells = []\r\n\r\n    /**\r\n     * Constant index of cells generated from target row\r\n     * @type Array\r\n     */\r\n    let constIndex = []\r\n\r\n    /**\r\n     * This is the podtable instance\r\n     */\r\n    let _this = this\r\n\r\n    /**\r\n     * This holds the current cell that is hidden\r\n     * @returns Number\r\n     */\r\n    _this.current\r\n\r\n    /**\r\n     * Process the config options passed\r\n     * @returns void\r\n     */\r\n    processConfig()\r\n\r\n    /**\r\n     * Attach event listeners for control toggle\r\n     * @returns void\r\n     */\r\n    setToggleCell(table)\r\n\r\n    /**\r\n     * Renders the table for the first instance\r\n     * @returns void\r\n     */\r\n    render()\r\n\r\n    /**\r\n     * Starts a mutation observer\r\n     * @returns void\r\n     */\r\n    ayncRedraw(table)\r\n\r\n    /**\r\n     * Set rendering target row\r\n     * @param {HTMLTableElement} table \r\n     */\r\n    function setTargetRow(table) {\r\n        if (table.tBodies[0].rows.length <= 0) {\r\n            targetRow = table.tHead.rows[0]\r\n        } else {\r\n            targetRow = table.tBodies[0].rows[0]\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * set the wrapper for podtable\r\n     */\r\n    function setWrapper() {\r\n        tableContainer = document.createElement('div')\r\n        tableContainer.setAttribute('id', 'podtable-container')\r\n        table.parentNode.insertBefore(tableContainer, table)\r\n        tableContainer.appendChild(table)\r\n    }\r\n\r\n    /**\r\n     * Perform health check and if it fail will throw an error\r\n     * And set the proper target row\r\n     * @param {HTMLTableElement} table \r\n     */\r\n    function healthCheck(table) {\r\n        if (!(table instanceof HTMLTableElement) || table == null || table.tHead == null) {\r\n            throw new Error('Invalid HTMLTableElement')\r\n        }\r\n\r\n        if (table.tHead.rows.length <= 0 || table.tHead.rows[0].cells.length < 0) {\r\n            throw new Error('Invalid tHead HTMLTableRowElement')\r\n        }\r\n\r\n        if (table.tBodies.length <= 0 || table.tBodies.length > 1) {\r\n            throw new Error('Table should have only one TBODY')\r\n        }\r\n\r\n        setTargetRow(table)\r\n        setWrapper()\r\n    }\r\n\r\n    /**\r\n     * Sets the control cells CSS clasess\r\n     * @param {String} tableEl \r\n     */\r\n    function setToggleCell(table) {\r\n        table.tHead.rows[0].lastElementChild.classList.add('main-toggle')\r\n\r\n        for (let row of table.tBodies[0].rows) {\r\n            row.lastElementChild.classList.add('toggle')\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The method process the config options\r\n     * - Set cell hidden priority from the right\r\n     * - Set indexes of cells to keep\r\n     */\r\n    function processConfig() {\r\n        let tempConst = []\r\n\r\n        for (let ci = 0; ci < targetRow.cells.length; ci++) {\r\n            tempConst.push(ci)\r\n        }\r\n\r\n        if (Array.isArray(options.priority) && options.priority.length > 0 ) {\r\n            constIndex = Array.from(new Set(options.priority.concat(tempConst.reverse())))\r\n        } else {\r\n            constIndex = tempConst.reverse()\r\n        }\r\n\r\n        if (! Array.isArray(options.keepCell)) {\r\n            throw TypeError('keepCell is not an array') \r\n        } else {\r\n            options.keepCell.push(0, tempConst.length - 1)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create HTMLTableRowElement element & append cell column data\r\n     * @param {HTMLCollection} cells \r\n     * @returns HTMLTableRowElement\r\n     */\r\n    function childRow (cells) {\r\n        let tr = document.createElement('tr')\r\n        let gridTD = document.createElement('td')\r\n        let gridRow = document.createElement('div')\r\n        \r\n        gridTD.colSpan = constIndex.length\r\n        gridRow.classList.add('child-grid-row')\r\n        tr.classList.add('child')\r\n    \r\n        for (let i = 0; i < cells.length; i++) {\r\n            gridRow.append(cells[i])\r\n        }\r\n        \r\n        gridTD.append(gridRow)\r\n        tr.append(gridTD)\r\n    \r\n        return tr\r\n    }\r\n\r\n    /**\r\n     * Create HTMLElement to append to child row\r\n     * @param {HTMLTableCellElement} el\r\n     * @returns HTMLElement\r\n     */\r\n    function gridCol(el) {\r\n        let gridCol = document.createElement('div')\r\n        gridCol.classList.add('child-grid-col')\r\n    \r\n        let dataColName = document.createElement('div')\r\n        let dataColDesc = document.createElement('div')\r\n        dataColName.innerHTML = table.tHead.rows[0].cells[el.cellIndex].innerHTML\r\n        dataColDesc.innerHTML = el.innerHTML\r\n    \r\n        gridCol.append(dataColName)\r\n        gridCol.append(dataColDesc)\r\n        \r\n        return gridCol\r\n    }\r\n\r\n    /**\r\n     * Toggle single child row and calculate hidden element for the row \r\n     * @param {event} e\r\n     */\r\n    function toggle(e) {\r\n        if (hiddenCells.length <= 0) { return }\r\n        \r\n        let parent = e.currentTarget.parentElement\r\n\r\n        if(parent.classList.contains('has-child')) {\r\n            parent.classList.remove('has-child')\r\n            parent.nextElementSibling.remove()\r\n        } else {\r\n            parent.classList.add('has-child')\r\n            let isHidden = []\r\n            for (let i = 0; i < parent.cells.length; i++) {\r\n                if (parent.cells[i].classList.contains('hidden')) {\r\n                    isHidden.push(gridCol(parent.cells[i]))\r\n                }\r\n            }\r\n\r\n            parent.parentNode.insertBefore(childRow(isHidden), parent.nextSibling)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handles toggle all child rows event by checking which rows \r\n     * has child to close and which rows has no child to open\r\n     * @param {event} e\r\n     */\r\n    function toggleAll(e) {\r\n        if (hiddenCells.length <= 0) { return }\r\n\r\n        let toggleEls = document.querySelectorAll('.toggle')\r\n        let toggler = e.currentTarget\r\n\r\n        if(toggler.classList.contains('expanded')) {\r\n            for (let i = 0; i < toggleEls.length; i++) {\r\n                let togsParent = toggleEls[i].parentElement\r\n                if (togsParent.classList.contains('has-child')) {\r\n                    toggleEls[i].click()\r\n                }\r\n            }\r\n            \r\n            toggler.classList.remove('expanded')\r\n        } else {\r\n            for (let i = 0; i < toggleEls.length; i++) {\r\n                let togsParent = toggleEls[i].parentElement\r\n                if (! togsParent.classList.contains('has-child')) {\r\n                    toggleEls[i].click()\r\n                }\r\n            }\r\n\r\n            toggler.classList.add('expanded')\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds click Event listener to rows with css class of \r\n     * toggle and main-toggle so as to toggle child rows\r\n     */\r\n    function addToggleListener () {\r\n        let togElements = document.querySelectorAll('.toggle')\r\n        for (let i = 0; i < togElements.length; i++) {\r\n            togElements[i].addEventListener('click', (e) => {\r\n                toggle(e)\r\n            })\r\n        }\r\n\r\n        let mainToggle = document.querySelector('.main-toggle')\r\n        mainToggle.addEventListener('click', (e) => {\r\n            toggleAll(e)\r\n        })\r\n    }\r\n\r\n    /**\r\n     * Check if there are hidden elements ands determine when to show\r\n     * child row toggle button and also clean up unused css class.\r\n     */\r\n    function doTogglerScreen () {\r\n        if(hiddenCells.length > 0) {\r\n            table.classList.add('show-toggle')\r\n        } else {\r\n            document.querySelectorAll('.has-child').forEach(el => {\r\n                el.classList.remove('has-child')\r\n            })\r\n\r\n            table.classList.remove('show-toggle')\r\n            table.tHead.rows[0].cells[table.tHead.rows[0].cells.length - 1].classList.remove('expanded')\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Check for open child rows to enable reactivity as window resizes\r\n     * then apply changes, item are remove and added every time window resize\r\n     * and its like this so as to get an updated data from the cells\r\n     * child row are redrawn on each control toggle.\r\n     */\r\n    function childRowListener () {\r\n        let childRows = document.querySelectorAll('tr.child')\r\n        \r\n        if(childRows.length > 0) {\r\n            let parentRows = []\r\n\r\n            for (let row of childRows) {\r\n                parentRows.push(row.previousElementSibling)\r\n            }\r\n\r\n            // Iterate from parents elements down to child elements\r\n            for (let p = 0; p < parentRows.length; p++) {\r\n                let isHidden = []\r\n                \r\n                for (let cell of parentRows[p].cells) {\r\n                    if (cell.classList.contains('hidden')) {\r\n                        isHidden.push(gridCol(cell))\r\n                    }\r\n                }\r\n\r\n                // we will remove the existing child row and put another one with new data\r\n                // we also check if the hidden cells length > 0 before inserting a new child row\r\n                // so as to avoid empty child rows and orphaned child rows\r\n                parentRows[p].nextElementSibling.remove()\r\n                \r\n                if(hiddenCells.length > 0) {\r\n                    parentRows[p].after(childRow(isHidden))\r\n                }\r\n\r\n                doTogglerScreen()\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Hide cells that falls into maximum squishitude\r\n     * Dispatch event for the current hidden cells index\r\n     * @param {Number} index \r\n     */\r\n    function hideMain(index, pt = table) {\r\n        hiddenCells.push(index)\r\n\r\n        for (let row of pt.rows) {\r\n            if (!row.classList.contains('child')) {\r\n                row.cells[index].classList.add('hidden')\r\n            }\r\n        }\r\n\r\n        eventDispatch(index)\r\n    }\r\n\r\n    /**\r\n     * Here we remove the hidden class and flush the hidden cells \r\n     * array so as to restart procedure for the current viewport.\r\n     */\r\n    function flush() {\r\n        for (let i = 0; i < hiddenCells.length; i++) {\r\n            for (let row of table.rows) {\r\n                if (!row.classList.contains('child')) {\r\n                    row.cells[hiddenCells[i]].classList.remove('hidden')\r\n                }\r\n            }\r\n        }\r\n\r\n        hiddenCells = []\r\n    }\r\n\r\n    /**\r\n     * Recalculate Cells thats needs to be hidden after flushing\r\n     */\r\n    function recalc() {\r\n        flush()\r\n        \r\n        for (let i = 0; i < constIndex.length; i++) {\r\n            if (targetRow.clientWidth > tableContainer.clientWidth) {\r\n                if (!hiddenCells.includes(constIndex[i])) {\r\n                    if (! options.keepCell.includes(constIndex[i])) {\r\n                        hideMain(constIndex[i])\r\n                        childRowListener()\r\n                    } \r\n                }\r\n            }\r\n        }\r\n        \r\n        doTogglerScreen()\r\n    }\r\n\r\n    /**\r\n     * This method recalculate which cells to hide or show and dispatch\r\n     * event with negative index to indicate there are no hiddenCells\r\n     */\r\n    function resize() {\r\n        recalc()\r\n        \r\n        if (hiddenCells.length <= 0) {\r\n            eventDispatch(-1)\r\n            childRowListener()\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * On page load calculate cells which  can fit into the current\r\n     * maximum squishitude: apply visibility, attach necessary listeners.\r\n     */\r\n    function mount() {\r\n        hiddenCells = []\r\n        let ilength = constIndex.length\r\n        \r\n        for (let i = 0; i < ilength; i++) {\r\n\r\n            if (targetRow.clientWidth > tableContainer.clientWidth) {\r\n                if(! hiddenCells.includes(constIndex[i])) {\r\n                    if (! options.keepCell.includes(constIndex[i])) {\r\n                        hideMain(constIndex[i])\r\n                    } \r\n                }\r\n            }\r\n        }\r\n        doTogglerScreen()\r\n    }\r\n\r\n    /**\r\n     * This is the resize counterpart for window resize event\r\n     * or element watcher event\r\n     * @see resize\r\n     */\r\n    function observeResize() {\r\n        recalc()\r\n        if (hiddenCells.length <= 0) {\r\n            eventDispatch(-1)\r\n            childRowListener()\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Here we will start new observer or attach resize listener base on\r\n     * client browser support for observer api.\r\n     */\r\n    function observed() {\r\n        let connected = false\r\n\r\n        try {\r\n            const observer = new ResizeObserver((entries) => {\r\n                if (entries[0].target.clientWidth !== oldTableContainerWidth) {\r\n                    observeResize()\r\n                }\r\n    \r\n                oldTableContainerWidth = entries[0].target.clientWidth\r\n            })\r\n\r\n            observer.observe(tableContainer)\r\n            connected = true\r\n        } catch (error) {\r\n            connected = false\r\n        }\r\n\r\n        return connected\r\n    }\r\n\r\n\r\n    /**\r\n     * Here we will do a mount, this will be at podtable instance\r\n     * then we will add child row event listeners after which we will\r\n     * use three ways in checking for resize on podtable\r\n     * * Resize observer which doesnt work on all browser\r\n     * * A custom watcher to watch element size\r\n     * * Lastly we fallback to window resize listener.\r\n     */\r\n    function render() {\r\n        mount()\r\n        addToggleListener()\r\n\r\n        if (!observed()) {\r\n            try {\r\n                watch(tableContainer, resize).start()\r\n            } catch (err) {\r\n                window.addEventListener('resize',  () => resize()) \r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * On body rows child list mutation essential row attributes and events\r\n     * will be lost hence the need to reset attriubtes and re attach necessary \r\n     * events listeners and also redispatch event.\r\n     * @param {HTMLTableElement} table \r\n     */\r\n    function ayncRedraw(table) {\r\n        let bodyNode = table.tBodies[0]\r\n\r\n        function doAttributes(node) {\r\n            node.lastElementChild.classList.add('toggle')\r\n            node.lastElementChild.addEventListener('click', (e) => toggle(e))\r\n        }\r\n\r\n        const callback = (mutationList) => {\r\n            for (const mutation of mutationList) {\r\n                if (mutation.type === 'childList' && mutation.addedNodes.length == 1) {\r\n                    if (mutation.addedNodes[0].tagName.toUpperCase() == 'TR' && !mutation.addedNodes[0].classList.contains('child')) {\r\n                        doAttributes(mutation.addedNodes[0])\r\n                        shouldPing()\r\n                    }                    \r\n                } else if (mutation.type === 'childList' && mutation.removedNodes.length == 1) {\r\n                    if (mutation.removedNodes[0].tagName.toUpperCase() == 'TR' &&\r\n                        !mutation.removedNodes[0].classList.contains('child') &&\r\n                        mutation.removedNodes[0].classList.contains('has-child')) {\r\n                        mutation.nextSibling.remove()\r\n                    }\r\n                }\r\n            }\r\n\r\n            setTargetRow(table)\r\n            flush()\r\n            mount()\r\n        }\r\n\r\n        const observer = new MutationObserver(callback)\r\n        observer.observe(bodyNode, { childList: true })\r\n    }\r\n\r\n    /**\r\n     * For every cells hidden this method will be called which check\r\n     * if events want to be received also attach hidden index to return object.\r\n     * @param {Number} index \r\n     */\r\n    function eventDispatch(index) {\r\n        _this.current = index\r\n\r\n        if (options.method) { shouldPing() }\r\n    }\r\n\r\n    /**\r\n     * Call the user attached method only if the event key is in the config \r\n     * object and it is set to true and we will  also wrap the function call \r\n     * in a try catch block to avoid code execution failure.\r\n     */\r\n    function shouldPing() {\r\n        if (options.method) {\r\n            try {\r\n                options.method(_this)\r\n            } catch (err) {\r\n                console.error(err)\r\n            }\r\n        }\r\n    }\r\n\r\n    if (options.method) { return _this }\r\n}\r\n\r\nexport default Podtable","function watch(element, fn) {\r\n    let _this = {}\r\n    let obj = document.createElement('object')\r\n\r\n    /**\r\n     * Event listener to the docs object\r\n     */\r\n    function resizeEvent () {\r\n        this.contentDocument.defaultView.addEventListener('resize', fn)\r\n    }\r\n\r\n    /**\r\n     * Attach event listener to object\r\n     */\r\n    _this.start = () => {\r\n        obj.classList.add('pt-object')\r\n        obj.type = 'text/html'\r\n        obj.data = 'about:blank'\r\n        obj.onload = resizeEvent\r\n        element.appendChild(obj)\r\n    }\r\n\r\n    /**\r\n     * dettach event listener and remove object\r\n     */\r\n    _this.stop = () => {\r\n        obj.contentDocument.defaultView.removeEventListener('resize', fn)\r\n        element.removeChild(obj)\r\n    }\r\n\r\n    return _this\r\n}\r\n\r\n/**\r\n * Returns the target table element\r\n * @param {String|HTMLTableElement} tableEl \r\n * @returns HTMLTableElement\r\n */\r\nfunction getTable(tableEl) {\r\n    if (typeof tableEl === 'string' || tableEl instanceof String) {\r\n        return document.querySelector(tableEl)\r\n    } else {\r\n        return tableEl\r\n    }\r\n}\r\n\r\nexport {\r\n    watch,\r\n    getTable\r\n}"],"names":["tableEl","config","targetRow","tableContainer","options","Object","assign","keepCell","priority","method","table","String","document","querySelector","getTable","HTMLTableElement","tHead","Error","rows","length","cells","tBodies","setTargetRow","setWrapper","healthCheck","oldTableContainerWidth","clientWidth","hiddenCells","constIndex","_this","this","createElement","setAttribute","parentNode","insertBefore","appendChild","childRow","tr","gridTD","gridRow","colSpan","classList","add","i","append","gridCol","el","dataColName","dataColDesc","innerHTML","cellIndex","toggle","e","parent","currentTarget","parentElement","contains","remove","nextElementSibling","isHidden","push","nextSibling","doTogglerScreen","querySelectorAll","forEach","childRowListener","childRows","parentRows","previousElementSibling","p","cell","after","hideMain","index","pt","row","eventDispatch","flush","recalc","includes","resize","mount","ilength","current","shouldPing","err","console","error","tempConst","ci","Array","isArray","from","Set","concat","reverse","TypeError","processConfig","lastElementChild","setToggleCell","togElements","addEventListener","toggleEls","toggler","click","toggleAll","addToggleListener","connected","ResizeObserver","entries","target","observe","observed","element","fn","obj","resizeEvent","contentDocument","defaultView","start","type","data","onload","stop","removeEventListener","removeChild","watch","window","render","bodyNode","MutationObserver","mutationList","mutation","addedNodes","tagName","toUpperCase","node","removedNodes","childList","ayncRedraw"],"mappings":"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"}
{"version":3,"file":"podtable.js","sources":["../src/podtable.js"],"sourcesContent":["function Podtable(tableEl, config = {}) {\r\n    /**\r\n     * The associated table that podtable will render\r\n     * @type HTMLTableElement\r\n     */\r\n    const table = document.querySelector(tableEl)\r\n\r\n    /**\r\n     * This is the squishitude determinant row\r\n     * @type HTMLTableRowElement\r\n     */\r\n    let targetRow\r\n\r\n    /**\r\n     * A wrapper for the render table\r\n     * @returns HTMLElement\r\n     */\r\n    let tableContainer\r\n\r\n    /**\r\n     * Perform an health check on the passed table\r\n     * @returns void\r\n     */\r\n    healthCheck(table)\r\n\r\n    /**\r\n     * This is store currently hidden cells\r\n     * @type Array\r\n     */\r\n    let hiddenCells = []\r\n\r\n    /**\r\n     * Constant index of cells generated from target row\r\n     * @type Array\r\n     */\r\n    let constIndex = []\r\n\r\n    /**\r\n     * These is store for cell that wont be hidden\r\n     * @type Array\r\n     */\r\n    let keepCell = [0]\r\n\r\n    /**\r\n     * This is the podtable instance\r\n     */\r\n    let _this = this\r\n\r\n    /**\r\n     * This holds the current cell that is hidden\r\n     * @returns Number\r\n     */\r\n    _this.current\r\n\r\n    /**\r\n     * Process the config options passed\r\n     * @returns void\r\n     */\r\n    processConfig(config)\r\n\r\n    /**\r\n     * Attach event listeners for control toggle\r\n     * @returns void\r\n     */\r\n    setToggleCell(table)\r\n\r\n    /**\r\n     * Renders the table for the first instance\r\n     * @returns void\r\n     */\r\n    render()\r\n\r\n    /**\r\n     * Starts a mutation observer\r\n     * @returns void\r\n     */\r\n    ayncRedraw(table)\r\n\r\n    /**\r\n     * Set rendering target row\r\n     * @param {Boolean} passed \r\n     */\r\n    function setTargetRow(passed) {\r\n        if (passed == -1) {\r\n            targetRow = table.tHead.rows[0]\r\n        } else if (passed == true) {\r\n            targetRow =  table.tBodies[0].rows[0]\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * set the wrapper for podtable\r\n     */\r\n    function setWrapper() {\r\n        tableContainer = document.createElement('div')\r\n        tableContainer.setAttribute('id', 'podtable-container')\r\n        table.parentNode.insertBefore(tableContainer, table)\r\n        tableContainer.appendChild(table)\r\n    }\r\n\r\n    /**\r\n     * Perform health check and if it fail will throw an error\r\n     * And set the proper target row\r\n     * @param {HTMLTableElement} table \r\n     */\r\n    function healthCheck(table) {\r\n        let passed = true\r\n\r\n        if (table === null) {\r\n            throw new Error('Unable to access target HTMLTableElement')\r\n        }\r\n\r\n        if (!(table instanceof HTMLTableElement)) {\r\n            throw new Error('Element is not an HTMLTableElement')\r\n        }\r\n\r\n        if (table.tHead === null) {\r\n            throw new Error('Table should have only one THEAD')\r\n        }\r\n\r\n        if (table.tHead.rows.length <= 0) {\r\n            throw new Error('tHead doesnt contain HTMLTableRowElement')\r\n        }\r\n\r\n        if (table.tHead.rows[0].cells.length < 2) {\r\n            throw new Error('tHead HTMLTableRowElement should have atleast 2 cells')\r\n        }\r\n\r\n        if (table.tBodies.length <= 0 || table.tBodies.length > 1) {\r\n            throw new Error('Table should have only one TBODY')\r\n        }\r\n\r\n        if (table.tBodies[0].rows.length <= 0) {\r\n            passed =  -1\r\n        }\r\n\r\n        setTargetRow(passed)\r\n        setWrapper()\r\n    }\r\n\r\n    /**\r\n     * Sets the control cells CSS clasess\r\n     * @param {String} tableEl \r\n     */\r\n    function setToggleCell(table) {\r\n        table.tHead.rows[0].lastElementChild.classList.add('main-toggle')\r\n\r\n        for (let row of table.tBodies[0].rows) {\r\n            row.lastElementChild.classList.add('toggle')\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The method process the config options\r\n     * * Set cell hiddenp priority from the right\r\n     * * Set indexes of cells to keep\r\n     * @param {Object} config \r\n     */\r\n    function processConfig(config) {\r\n        let tempConst = []\r\n\r\n        for (let ci = 0; ci < targetRow.cells.length; ci++) {\r\n            tempConst.push(ci)\r\n        }\r\n\r\n        if (Object.prototype.hasOwnProperty.call(config, 'priority') &&\r\n            Array.isArray(config.priority) && config.priority.length > 0 ) {\r\n            constIndex = Array.from(new Set(config.priority.concat(tempConst.reverse())))\r\n        } else {\r\n            constIndex = tempConst.reverse()\r\n        }\r\n\r\n        keepCell.push(tempConst.length - 1)\r\n\r\n        if(Object.prototype.hasOwnProperty.call(config, 'keepCell')) {\r\n            if (! Array.isArray(config.keepCell)) {\r\n                throw TypeError('keep cell must be of type array') \r\n            } else {\r\n                keepCell = [...keepCell, ...config.keepCell]\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create HTMLTableRowElement element & append cell column data\r\n     * @param {HTMLCollection} cells \r\n     * @returns Element Node\r\n     */\r\n    function childRow (cells) {\r\n        let tr = document.createElement('tr')\r\n        let gridTD = document.createElement('td')\r\n        let gridRow = document.createElement('div')\r\n        \r\n        gridTD.colSpan = constIndex.length\r\n        gridRow.classList.add('child-grid-row')\r\n        tr.classList.add('child')\r\n    \r\n        for (let i = 0; i < cells.length; i++) {\r\n            gridRow.append(cells[i])\r\n        }\r\n        \r\n        gridTD.append(gridRow)\r\n        tr.append(gridTD)\r\n    \r\n        return tr\r\n    }\r\n\r\n    /**\r\n     * Create HTMLElement to append to child row\r\n     * @param {HTMLTableRowElement} el\r\n     * @returns Element Node\r\n     */\r\n    function gridCol(el) {\r\n        let gridCol = document.createElement('div')\r\n        gridCol.classList.add('child-grid-col')\r\n    \r\n        let dataColName = document.createElement('div')\r\n        let dataColDesc = document.createElement('div')\r\n        dataColName.innerHTML = table.tHead.rows[0].cells[el.cellIndex].innerHTML\r\n        dataColDesc.innerHTML = el.innerHTML\r\n    \r\n        gridCol.append(dataColName)\r\n        gridCol.append(dataColDesc)\r\n        \r\n        return gridCol\r\n    }\r\n\r\n    /**\r\n     * Toggle single child row and calculate hidden element for the row \r\n     * @param {event} event\r\n     */\r\n    function toggle(e) {\r\n        if (hiddenCells.length <= 0) { return }\r\n        \r\n        let parent = e.currentTarget.parentElement\r\n\r\n        if(parent.classList.contains('has-child')) {\r\n            parent.classList.remove('has-child')\r\n            parent.nextElementSibling.remove()\r\n        } else {\r\n            parent.classList.add('has-child')\r\n            let isHidden = []\r\n            for (let i = 0; i < parent.cells.length; i++) {\r\n                if (parent.cells[i].classList.contains('hidden')) {\r\n                    isHidden.push(gridCol(parent.cells[i]))\r\n                }\r\n            }\r\n\r\n            parent.parentNode.insertBefore(childRow(isHidden), parent.nextSibling)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handles toggle all child rows event by checking which rows \r\n     * has child to close and which rows has no child to open\r\n     * @param {event} event\r\n     */\r\n    function toggleAll(e) {\r\n        if (hiddenCells.length <= 0) { return }\r\n\r\n        let toggleEls = document.querySelectorAll('.toggle')\r\n        let toggler = e.currentTarget\r\n\r\n        if(toggler.classList.contains('expanded')) {\r\n            for (let i = 0; i < toggleEls.length; i++) {\r\n                let togsParent = toggleEls[i].parentElement\r\n                if (togsParent.classList.contains('has-child')) {\r\n                    toggleEls[i].click()\r\n                }\r\n            }\r\n            \r\n            toggler.classList.remove('expanded')\r\n        } else {\r\n            for (let i = 0; i < toggleEls.length; i++) {\r\n                let togsParent = toggleEls[i].parentElement\r\n                if (! togsParent.classList.contains('has-child')) {\r\n                    toggleEls[i].click()\r\n                }\r\n            }\r\n\r\n            toggler.classList.add('expanded')\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds click Event listener to rows with css class of \r\n     * toggle and main-toggle so as to toggle child rows\r\n     */\r\n    function addToggleListener () {\r\n        let togElements = document.querySelectorAll('.toggle')\r\n        for (let i = 0; i < togElements.length; i++) {\r\n            togElements[i].addEventListener('click', (e) => {\r\n                toggle(e)\r\n            })\r\n        }\r\n\r\n        let mainToggle = document.querySelector('.main-toggle')\r\n        mainToggle.addEventListener('click', (e) => {\r\n            toggleAll(e)\r\n        })\r\n    }\r\n\r\n    /**\r\n     * Check if there are hidden elements ands determine when to show\r\n     * child row toggle button and also clean up unused css class.\r\n     */\r\n    function doTogglerScreen () {\r\n        if(hiddenCells.length > 0) {\r\n            table.classList.add('show-toggle')\r\n        } else {\r\n            document.querySelectorAll('.has-child').forEach(el => {\r\n                el.classList.remove('has-child')\r\n            })\r\n\r\n            table.classList.remove('show-toggle')\r\n            table.tHead.rows[0].cells[table.tHead.rows[0].cells.length - 1].classList.remove('expanded')\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Check for open child rows to enable reactivity as window resizes\r\n     * then apply changes, item are remove and added every time window resize\r\n     * and its like this so as to get an updated data from the cells\r\n     * parent row child row are redrawn on each control toggle.\r\n     */\r\n    function childRowListener () {\r\n        let openChildRow = document.querySelectorAll('.child')\r\n        \r\n        if(openChildRow.length > 0) {\r\n            let openChildParent = []\r\n\r\n            for (let i = 0; i < openChildRow.length; i++) {\r\n                openChildParent.push(openChildRow[i].previousElementSibling)\r\n            }\r\n\r\n            // Iterate from parents elements down to child elements\r\n            for (let p = 0; p < openChildParent.length; p++) {\r\n                let isHidden = []\r\n                \r\n                for (let cell of openChildParent[p].cells) {\r\n                    if (cell.classList.contains('hidden')) {\r\n                        isHidden.push(gridCol(cell))\r\n                    }\r\n                }\r\n\r\n                // we will remove the existing child row and put another one with new data\r\n                // we also check if the hidden cells length > 0 before inserting a new child row\r\n                // so as to avoid empty child rows and orphaned child rows\r\n                openChildParent[p].nextElementSibling.remove()\r\n                \r\n                if(hiddenCells.length > 0) {\r\n                    openChildParent[p].after(childRow(isHidden))\r\n                }\r\n\r\n                doTogglerScreen()\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Hide cells that falls into maximum squishitude\r\n     * Dispatch event for the current hidden cells index\r\n     * @param {Number} index \r\n     */\r\n    function hideMain(index, pt = table) {\r\n        hiddenCells.push(index)\r\n\r\n        for (let row of pt.rows) {\r\n            if (!row.classList.contains('child')) {\r\n                row.cells[index].classList.add('hidden')\r\n            }\r\n        }\r\n\r\n        eventDispatch(index)\r\n    }\r\n\r\n    /**\r\n     * Here we remove the hidden class and flush the hidden cells \r\n     * array so as to restart procedure for the current viewport.\r\n     */\r\n    function flush() {\r\n        for (let i = 0; i < hiddenCells.length; i++) {\r\n            for (let row of table.rows) {\r\n                if (!row.classList.contains('child')) {\r\n                    row.cells[hiddenCells[i]].classList.remove('hidden')\r\n                }\r\n            }\r\n        }\r\n\r\n        hiddenCells = []\r\n    }\r\n\r\n    /**\r\n     * Recalculate Cells thats needs to be hidden after flushing\r\n     */\r\n    function recalc() {\r\n        flush()\r\n        \r\n        for (let i = 0; i < constIndex.length; i++) {\r\n            if (targetRow.clientWidth > tableContainer.clientWidth) {\r\n                if (!hiddenCells.includes(constIndex[i])) {\r\n                    if (!keepCell.includes(constIndex[i])) {\r\n                        hideMain(constIndex[i])\r\n                        childRowListener()\r\n                    } \r\n                }\r\n            }\r\n        }\r\n        \r\n        doTogglerScreen()\r\n    }\r\n\r\n    /**\r\n     * Determines cels to show base on the maximum squishitude \r\n     * Call listener to enable reactivity. \r\n     * Dispatch event if there are no hidden cells.\r\n     */\r\n    function resize() {\r\n        recalc()\r\n        \r\n        if (hiddenCells.length <= 0) {\r\n            eventDispatch(-1)\r\n            childRowListener()\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * On page load calculate cells which  can fit into the current\r\n     * maximum squishitude: apply visibility, attach necessary listeners.\r\n     */\r\n    function mount() {\r\n        hiddenCells = []\r\n        let ilength = constIndex.length\r\n        \r\n        for (let i = 0; i < ilength; i++) {\r\n\r\n            if (targetRow.clientWidth > tableContainer.clientWidth) {\r\n                if(! hiddenCells.includes(constIndex[i])) {\r\n                    if (!keepCell.includes(constIndex[i])) {\r\n                        hideMain(constIndex[i])\r\n                    } \r\n                }\r\n            }\r\n        }\r\n        doTogglerScreen()\r\n    }\r\n\r\n\r\n    /**\r\n     * Initialize table process\r\n     */\r\n    function render() {\r\n        mount()\r\n        addToggleListener()\r\n        window.addEventListener('resize',  () => resize())\r\n    }\r\n\r\n    /**\r\n     * On body rows child list mutation essential row attributes and events\r\n     * will be lost hence the need to reset attriubtes and re attach necessary \r\n     * events listeners and also redispatch cells event but only the attached method\r\n     * @param {String} tableEl \r\n     */\r\n    function ayncRedraw(table) {\r\n        let bodyNode = table.tBodies[0]\r\n\r\n        function doAttributes(node) {\r\n            node.lastElementChild.classList.add('toggle')\r\n            node.lastElementChild.addEventListener('click', (e) => toggle(e))\r\n        }\r\n\r\n        const callback = (mutationList) => {\r\n            for (const mutation of mutationList) {\r\n                if (mutation.type === 'childList' && mutation.addedNodes.length === 1) {\r\n                    if (mutation.addedNodes[0].tagName == 'TR' && !mutation.addedNodes[0].classList.contains('child')) {\r\n                        doAttributes(mutation.addedNodes[0])\r\n                        shouldPing()\r\n                    }\r\n                } else if (mutation.type === 'childList' && mutation.removedNodes.length === 1) {\r\n                    if (mutation.removedNodes[0].tagName == 'TR' &&\r\n                        !mutation.removedNodes[0].classList.contains('child') &&\r\n                        mutation.removedNodes[0].classList.contains('has-child')) {\r\n                        mutation.nextSibling.remove()\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (table.tBodies[0].rows.length <= 0) {\r\n                targetRow = table.tHead.rows[0]\r\n            } else {\r\n                targetRow = table.tBodies[0].rows[0]\r\n            }\r\n\r\n            flush()\r\n            mount()\r\n        }\r\n\r\n        const observer = new MutationObserver(callback)\r\n        observer.observe(bodyNode, { childList: true })\r\n    }\r\n\r\n    /**\r\n     * For every cells hidden this method will be called which check\r\n     * if events want to be received also attach hidden index to return object.\r\n     * @param {Number} index \r\n     */\r\n    function eventDispatch(index) {\r\n        _this.current = index\r\n\r\n        if (config.event) { shouldPing() }\r\n    }\r\n\r\n    /**\r\n     * Call the user attached method only if the event key is in the config \r\n     * object and it is set to true and we will  also wrap the function call \r\n     * in a try catch block to avoid code execution failure.\r\n     */\r\n    function shouldPing() {\r\n        if (config.event) {\r\n            try {\r\n                config.method(_this)\r\n            } catch (error) {\r\n                console.error(error)\r\n            }\r\n        }\r\n    }\r\n\r\n    if (config.event) { return _this }\r\n}\r\n\r\nexport default Podtable"],"names":["tableEl","config","targetRow","tableContainer","table","document","querySelector","passed","Error","HTMLTableElement","tHead","rows","length","cells","tBodies","setTargetRow","setWrapper","healthCheck","hiddenCells","constIndex","keepCell","_this","this","createElement","setAttribute","parentNode","insertBefore","appendChild","childRow","tr","gridTD","gridRow","colSpan","classList","add","i","append","gridCol","el","dataColName","dataColDesc","innerHTML","cellIndex","toggle","e","parent","currentTarget","parentElement","contains","remove","nextElementSibling","isHidden","push","nextSibling","doTogglerScreen","querySelectorAll","forEach","childRowListener","openChildRow","openChildParent","previousElementSibling","p","cell","after","hideMain","index","pt","row","eventDispatch","flush","mount","ilength","clientWidth","includes","current","event","shouldPing","method","error","console","tempConst","ci","Object","prototype","hasOwnProperty","call","Array","isArray","priority","from","Set","concat","reverse","TypeError","processConfig","lastElementChild","setToggleCell","togElements","addEventListener","toggleEls","toggler","click","toggleAll","addToggleListener","window","recalc","bodyNode","MutationObserver","mutationList","mutation","type","addedNodes","tagName","node","removedNodes","observe","childList","ayncRedraw"],"mappings":"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"}
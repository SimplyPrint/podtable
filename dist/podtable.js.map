{"version":3,"file":"podtable.js","sources":["../src/podtable.js","../src/utils.js"],"sourcesContent":["import { watch, getTable, detachRows } from './utils'\r\n\r\nfunction Podtable(tableEl, config = {}) {\r\n    /**\r\n     * default config options\r\n     * @type Object\r\n     */\r\n    let defaultOptions = {\r\n        keepCell: [],\r\n        priority: [],\r\n        method: null,\r\n        rowGroup: false\r\n    }\r\n\r\n    /**\r\n     * Podtable instance\r\n     * @return object\r\n     */\r\n    let _this = {}\r\n\r\n    /**\r\n     * config options\r\n     */\r\n    let options = Object.assign({}, defaultOptions, config)\r\n\r\n    /**\r\n     * The associated table that podtable will render\r\n     * @returns HTMLTableElement\r\n     */\r\n    const table = getTable(tableEl)\r\n\r\n    /**\r\n     * This is the squishitude determinant row\r\n     * @type HTMLTableRowElement\r\n     */\r\n    let targetRow\r\n\r\n    /**\r\n     * A wrapper for the render table\r\n     * @returns HTMLElement\r\n     */\r\n    let tableContainer\r\n\r\n    /**\r\n     * Perform an health check on the passed table\r\n     * @returns void\r\n     */\r\n    healthCheck(table)\r\n\r\n    /**\r\n     * Cache container width after health check passed\r\n     */\r\n    let oldTableContainerWidth = tableContainer.clientWidth\r\n\r\n    /**\r\n     * This is store for currently hidden cells\r\n     * @type Array\r\n     */\r\n    let hiddenCells = []\r\n\r\n    /**\r\n     * Constant index of cells generated from target row\r\n     * @type Array\r\n     */\r\n    let constIndex = []\r\n\r\n    /**\r\n     * @type object\r\n     */\r\n    let state = { current: -1 }\r\n\r\n    /**\r\n     * Process the config options passed\r\n     * @returns void\r\n     */\r\n    processConfig()\r\n\r\n    /**\r\n     * Attach event listeners for control toggle\r\n     * @returns void\r\n     */\r\n    setToggleCell(table)\r\n\r\n    /**\r\n     * Resize event method\r\n     */\r\n    _this.watchResize = false\r\n\r\n    /**\r\n     * Resize event method\r\n     */\r\n    _this.nativeResize = false\r\n\r\n    /**\r\n     * observer event method\r\n     */\r\n    _this.observer = false\r\n\r\n    /**\r\n     * Renders the table for the first instance\r\n     * @returns void\r\n     */\r\n    render()\r\n\r\n    /**\r\n     * Starts a mutation observer\r\n     * @returns void\r\n     */\r\n    watchMutation(table)\r\n\r\n    /**\r\n     * Set rendering target row\r\n     * @param {HTMLTableElement} table \r\n     */\r\n    function setTargetRow(table) {\r\n        targetRow = table.tHead.rows[0]\r\n    }\r\n\r\n    /**\r\n     * set the wrapper for podtable\r\n     */\r\n    function setWrapper() {\r\n        tableContainer = document.createElement('div')\r\n        tableContainer.setAttribute('id', 'podtable-container')\r\n        table.parentNode.insertBefore(tableContainer, table)\r\n        tableContainer.appendChild(table)\r\n    }\r\n\r\n    /**\r\n     * Perform health check and if it fail will throw an error\r\n     * @param {HTMLTableElement} table \r\n     */\r\n    function healthCheck(table) {\r\n        if (!(table instanceof HTMLTableElement) || table == null || table.tHead == null) {\r\n            throw new Error('Invalid HTMLTableElement')\r\n        }\r\n\r\n        if (table.tHead.rows.length <= 0 || table.tHead.rows[0].cells.length < 0) {\r\n            throw new Error('Invalid tHead HTMLTableRowElement')\r\n        }\r\n\r\n        setTargetRow(table)\r\n        setWrapper()\r\n    }\r\n\r\n    /**\r\n     * Sets the control cells CSS clasess\r\n     * @param {String} tableEl \r\n     */\r\n    function setToggleCell(table) {\r\n        for (let row of table.rows) {\r\n            if (row.parentElement.tagName.toUpperCase() == 'TBODY') {\r\n                if (!row.hasAttribute('data-ptr-ignore')) {\r\n                    row.lastElementChild.classList.add('toggle')\r\n                }\r\n            } else {\r\n                row.lastElementChild.classList.add('main-toggle')\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set cell hidden priority from the right\r\n     * Set indexes of cells to keep\r\n     */\r\n    function processConfig() {\r\n        let tempConst = []\r\n\r\n        for (let ci = 0; ci < targetRow.cells.length; ci++) {\r\n            tempConst.push(ci)\r\n        }\r\n\r\n        if (Array.isArray(options.priority) && options.priority.length > 0) {\r\n            constIndex = Array.from(new Set(options.priority.concat(tempConst.reverse())))\r\n        } else {\r\n            constIndex = tempConst.reverse()\r\n        }\r\n\r\n        if (!Array.isArray(options.keepCell)) {\r\n            throw TypeError('keepCell is not an array')\r\n        } else {\r\n            options.keepCell.push(0, tempConst.length - 1)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create HTMLTableRowElement & append cell column data\r\n     * @param {HTMLCollection} cells \r\n     * @returns HTMLTableRowElement\r\n     */\r\n    function childRow(cells) {\r\n        let tr = document.createElement('tr')\r\n        let gridTD = document.createElement('td')\r\n        let gridRow = document.createElement('div')\r\n\r\n        gridTD.colSpan = constIndex.length\r\n        gridRow.classList.add('child-grid-row')\r\n        tr.classList.add('child')\r\n\r\n        for (let i = 0; i < cells.length; i++) {\r\n            gridRow.append(cells[i])\r\n        }\r\n\r\n        gridTD.append(gridRow)\r\n        tr.append(gridTD)\r\n\r\n        return tr\r\n    }\r\n\r\n    /**\r\n     * Create HTMLElement to append to child row\r\n     * @param {HTMLTableCellElement} el\r\n     * @returns HTMLElement\r\n     */\r\n    function gridCol(el) {\r\n        let gridCol = document.createElement('div')\r\n        gridCol.classList.add('child-grid-col')\r\n\r\n        let dataColName = document.createElement('div')\r\n        let dataColDesc = document.createElement('div')\r\n        dataColName.innerHTML = table.tHead.rows[0].cells[el.cellIndex].innerHTML\r\n        dataColDesc.innerHTML = el.innerHTML\r\n\r\n        gridCol.append(dataColName)\r\n        gridCol.append(dataColDesc)\r\n\r\n        return gridCol\r\n    }\r\n\r\n    /**\r\n     * Toggle single child row and calculate hidden element for the row \r\n     * @param {event} e\r\n     */\r\n    function toggle(e) {\r\n        if (hiddenCells.length <= 0) { return }\r\n\r\n        let parent = e.currentTarget.parentElement\r\n\r\n        if (parent.classList.contains('has-child')) {\r\n            parent.classList.remove('has-child')\r\n            parent.nextElementSibling.remove()\r\n        } else {\r\n            parent.classList.add('has-child')\r\n            let isHidden = []\r\n            for (let i = 0; i < parent.cells.length; i++) {\r\n                if (parent.cells[i].classList.contains('hidden')) {\r\n                    isHidden.push(gridCol(parent.cells[i]))\r\n                }\r\n            }\r\n\r\n            parent.parentNode.insertBefore(childRow(isHidden), parent.nextSibling)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handles toggle all child rows event by checking which rows \r\n     * has child to close and which rows has no child to open\r\n     * @param {event} e\r\n     */\r\n    function toggleAll(e) {\r\n        if (hiddenCells.length <= 0) { return }\r\n\r\n        let toggleEls = document.querySelectorAll('.toggle')\r\n        let toggler = e.currentTarget\r\n\r\n        if (toggler.classList.contains('expanded')) {\r\n            for (let i = 0; i < toggleEls.length; i++) {\r\n                let togsParent = toggleEls[i].parentElement\r\n                if (togsParent.classList.contains('has-child')) {\r\n                    toggleEls[i].click()\r\n                }\r\n            }\r\n\r\n            toggler.classList.remove('expanded')\r\n        } else {\r\n            for (let i = 0; i < toggleEls.length; i++) {\r\n                let togsParent = toggleEls[i].parentElement\r\n                if (!togsParent.classList.contains('has-child')) {\r\n                    toggleEls[i].click()\r\n                }\r\n            }\r\n\r\n            toggler.classList.add('expanded')\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds click Event listener to rows with css class of \r\n     * toggle and main-toggle so as to toggle child rows\r\n     * @return void\r\n     */\r\n    function addToggleListener() {\r\n        let togElements = document.querySelectorAll('.toggle')\r\n        for (let i = 0; i < togElements.length; i++) {\r\n            togElements[i].addEventListener('click', toggle)\r\n        }\r\n\r\n        let mainToggle = document.querySelector('.main-toggle')\r\n        mainToggle.addEventListener('click', toggleAll)\r\n    }\r\n\r\n    /**\r\n     * Remove control toggle listener on rows\r\n     * @return object\r\n     */\r\n    function removeToggleListener() {\r\n        let togElements = document.querySelectorAll('.toggle')\r\n        for (let i = 0; i < togElements.length; i++) {\r\n            togElements[i].removeEventListener('click', toggle)\r\n        }\r\n\r\n        let mainToggle = document.querySelector('.main-toggle')\r\n        mainToggle.removeEventListener('click', toggleAll)\r\n    }\r\n\r\n    /**\r\n     * Check if there are hidden elements ands determine when to show\r\n     * child row toggle button and also clean up unused css class.\r\n     */\r\n    function doTogglerScreen() {\r\n        if (hiddenCells.length > 0) {\r\n            table.classList.add('show-toggle')\r\n        } else {\r\n            document.querySelectorAll('.has-child').forEach(el => {\r\n                el.classList.remove('has-child')\r\n            })\r\n\r\n            table.classList.remove('show-toggle')\r\n            table.tHead.rows[0].cells[table.tHead.rows[0].cells.length - 1].classList.remove('expanded')\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Check for open child rows to enable reactivity as window resizes\r\n     * then apply changes, item are remove and added every time window resize\r\n     * and its like this so as to get an updated data from the cells\r\n     * child row are redrawn on each control toggle.\r\n     */\r\n    function childRowListener() {\r\n        let childRows = document.querySelectorAll('tr.child')\r\n\r\n        if (childRows.length > 0) {\r\n            let parentRows = []\r\n\r\n            for (let row of childRows) {\r\n                parentRows.push(row.previousElementSibling)\r\n            }\r\n\r\n            // Iterate from parents elements down to child elements\r\n            for (let p = 0; p < parentRows.length; p++) {\r\n                let isHidden = []\r\n\r\n                for (let cell of parentRows[p].cells) {\r\n                    if (cell.classList.contains('hidden')) {\r\n                        isHidden.push(gridCol(cell))\r\n                    }\r\n                }\r\n\r\n                // we will remove the existing child row and put another one with new data\r\n                // we also check if the hidden cells length > 0 before inserting a new child row\r\n                // so as to avoid empty child rows and orphaned child rows\r\n                parentRows[p].nextElementSibling.remove()\r\n\r\n                if (hiddenCells.length > 0) {\r\n                    parentRows[p].after(childRow(isHidden))\r\n                }\r\n\r\n                doTogglerScreen()\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Hide cells that falls into maximum squishitude\r\n     * Dispatch event for the current hidden cells index\r\n     * @param {Number} index \r\n     */\r\n    function hideMain(index, pt = table) {\r\n        hiddenCells.push(index)\r\n\r\n        for (let row of pt.rows) {\r\n            if (!row.classList.contains('child') && !row.hasAttribute('data-ptr-ignore')) {\r\n                row.cells[index].classList.add('hidden')\r\n            }\r\n        }\r\n\r\n        eventDispatch(index)\r\n    }\r\n\r\n    /**\r\n     * Here we remove the hidden class and flush the hidden cells \r\n     * array so as to restart procedure for the current viewport.\r\n     */\r\n    function flush() {\r\n        for (let i = 0; i < hiddenCells.length; i++) {\r\n            for (let row of table.rows) {\r\n                if (!row.classList.contains('child') && !row.hasAttribute('data-ptr-ignore')) {\r\n                    row.cells[hiddenCells[i]].classList.remove('hidden')\r\n                }\r\n            }\r\n        }\r\n\r\n        hiddenCells = []\r\n    }\r\n\r\n    /**\r\n     * Recalculate Cells thats needs to be hidden after flushing\r\n     */\r\n    function recalc() {\r\n        flush()\r\n\r\n        for (let i = 0; i < constIndex.length; i++) {\r\n            if (targetRow.clientWidth > tableContainer.clientWidth) {\r\n                if (!hiddenCells.includes(constIndex[i])) {\r\n                    if (!options.keepCell.includes(constIndex[i])) {\r\n                        hideMain(constIndex[i])\r\n                        childRowListener()\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        doTogglerScreen()\r\n    }\r\n\r\n    /**\r\n     * This method recalculate which cells to hide or show and dispatch\r\n     * event with negative index to indicate there are no hiddenCells\r\n     */\r\n    function resize() {\r\n        recalc()\r\n\r\n        if (hiddenCells.length <= 0) {\r\n            eventDispatch(-1)\r\n            childRowListener()\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * On mounted calculate cells which  can fit into the current\r\n     * maximum squishitude: apply visibility, attach listeners.\r\n     */\r\n    function mount() {\r\n        hiddenCells = []\r\n        let ilength = constIndex.length\r\n\r\n        for (let i = 0; i < ilength; i++) {\r\n\r\n            if (targetRow.clientWidth > tableContainer.clientWidth) {\r\n                if (!hiddenCells.includes(constIndex[i])) {\r\n                    if (!options.keepCell.includes(constIndex[i])) {\r\n                        hideMain(constIndex[i])\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        doTogglerScreen()\r\n    }\r\n\r\n    /**\r\n     * This is the resize counterpart for window resize event\r\n     * or element watcher event\r\n     * @see resize\r\n     */\r\n    function observeResize() {\r\n        recalc()\r\n        if (hiddenCells.length <= 0) {\r\n            eventDispatch(-1)\r\n            childRowListener()\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handles resize listener\r\n     * @returns boolean|ResizeObserver\r\n     */\r\n    function observed() {\r\n        try {\r\n            _this.nativeResize = new ResizeObserver((entries) => {\r\n                if (entries[0].target.clientWidth !== oldTableContainerWidth) {\r\n                    observeResize()\r\n                }\r\n\r\n                oldTableContainerWidth = entries[0].target.clientWidth\r\n            })\r\n\r\n            _this.nativeResize.observe(tableContainer)\r\n            return true\r\n        } catch (err) {\r\n            return false\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Starts an observer at podtable instance and \r\n     * attach necessary listeners\r\n     */\r\n    function render() {\r\n        mount()\r\n        addToggleListener()\r\n\r\n        if (!observed()) {\r\n            try {\r\n                _this.watchResize = watch(tableContainer, resize)\r\n                _this.watchResize.start()\r\n            } catch (err) {\r\n                window.addEventListener('resize', resize) \r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Revert all events made to the DOM\r\n     */\r\n    function destroy() {\r\n        window.removeEventListener('resize', resize)\r\n        flush()\r\n\r\n        detachRows(table, tableContainer, _this)\r\n        removeToggleListener()\r\n    }\r\n\r\n    /**\r\n     * Revert any alteration to the table in the DOM\r\n     * and detach events\r\n     * @returns void\r\n     */\r\n    state.destroy = () => destroy()\r\n\r\n    /**\r\n     * Handles childList mutations by re-attaching attributes, \r\n     * events and dispatching events\r\n     * @param {HTMLTableElement} table \r\n     */\r\n    function watchMutation(table) {\r\n        function resetRow(node) {\r\n            if (!node.hasAttribute('data-ptr-ignore')) {\r\n                node.lastElementChild.classList.add('toggle')\r\n                node.lastElementChild.addEventListener('click', (e) => toggle(e))\r\n            }\r\n        }\r\n\r\n        const callback = (mutations) => {\r\n            for (const mutation of mutations) {\r\n                if (mutation.type == 'childList' && mutation.addedNodes.length == 1) {\r\n                    if (mutation.addedNodes[0].tagName.toUpperCase() == 'TBODY') {\r\n                        for (let node of mutation.addedNodes[0].children) {\r\n                            resetRow(node)\r\n                            shouldPing()\r\n                        }\r\n                    }\r\n\r\n                    if (mutation.addedNodes[0].tagName.toUpperCase() == 'TR' && !mutation.addedNodes[0].classList.contains('child')) {\r\n                        resetRow(mutation.addedNodes[0])\r\n                        shouldPing()\r\n                    }\r\n                } else if (mutation.type == 'childList' && mutation.removedNodes.length == 1) {\r\n                    if (mutation.removedNodes[0].tagName.toUpperCase() == 'TR' &&\r\n                        !mutation.removedNodes[0].classList.contains('child') &&\r\n                        mutation.removedNodes[0].classList.contains('has-child')) {\r\n                        mutation.nextSibling.remove()\r\n                    }\r\n                }\r\n            }\r\n\r\n            setTargetRow(table)\r\n            flush()\r\n            mount()\r\n        }\r\n\r\n        let observable = options.rowGroup ? table : table.tBodies[0]\r\n        _this.observer = new MutationObserver(callback)\r\n        _this.observer.observe(observable, { childList: true })\r\n    }\r\n\r\n    /**\r\n     * Dispatch event for the current hidden cell index\r\n     * @param {Number} index \r\n     */\r\n    function eventDispatch(index) {\r\n        state.current = index\r\n\r\n        if (options.method) { shouldPing() }\r\n    }\r\n\r\n    /**\r\n     * Dispatchs event\r\n     */\r\n    function shouldPing() {\r\n        if (options.method) {\r\n            try {\r\n                options.method(state)\r\n            } catch (err) {\r\n                console.error(err)\r\n            }\r\n        }\r\n    }\r\n\r\n    return state \r\n}\r\n\r\nexport default Podtable","export function watch(element, fn) {\r\n    let _this = {}\r\n    let obj = document.createElement('object')\r\n\r\n    /**\r\n     * Event listener to the docs object\r\n     */\r\n    function resizeEvent () {\r\n        this.contentDocument.defaultView.addEventListener('resize', fn)\r\n    }\r\n\r\n    /**\r\n     * Attach event listener to object\r\n     */\r\n    _this.start = () => {\r\n        obj.classList.add('pt-object')\r\n        obj.type = 'text/html'\r\n        obj.data = 'about:blank'\r\n        obj.onload = resizeEvent\r\n        element.appendChild(obj)\r\n    }\r\n\r\n    /**\r\n     * dettach event listener and remove object\r\n     */\r\n    _this.stop = () => {\r\n        obj.contentDocument.defaultView.removeEventListener('resize', fn)\r\n        element.removeChild(obj)\r\n    }\r\n\r\n    return _this\r\n}\r\n\r\n/**\r\n * Returns the target table element\r\n * @param {String|HTMLTableElement} tableEl \r\n * @returns HTMLTableElement\r\n */\r\nexport function getTable(tableEl) {\r\n    if (typeof tableEl === 'string' || tableEl instanceof String) {\r\n        return document.querySelector(tableEl)\r\n    } else {\r\n        return tableEl\r\n    }\r\n}\r\n\r\n/**\r\n * Detach child rows from the dom and remove classes\r\n * @param { HTMLTableElement }\r\n */\r\nexport function detachRows(table, container, _this) {\r\n    _this.observer.disconnect()\r\n\r\n    if (typeof _this.nativeResize !== undefined && _this.nativeResize !== false)\r\n        _this.nativeResize.disconnect()\r\n    \r\n    if (typeof _this.watchResize !== undefined && _this.watchResize !== false)\r\n        _this.watchResize.stop()\r\n\r\n    let parentRows = table.querySelectorAll('tr.has-child')\r\n\r\n    for (let row of parentRows) {\r\n        row.classList.remove('has-child')\r\n        if (row.nextElementSibling.classList.contains('child')) {\r\n            row.nextElementSibling.remove()\r\n        }\r\n    }\r\n\r\n    table.classList.remove('show-toggle')\r\n    container.replaceWith(...container.childNodes)\r\n}"],"names":["tableEl","config","targetRow","tableContainer","_this","options","Object","assign","keepCell","priority","method","rowGroup","table","String","document","querySelector","getTable","HTMLTableElement","tHead","Error","rows","length","cells","setTargetRow","setWrapper","healthCheck","oldTableContainerWidth","clientWidth","hiddenCells","constIndex","state","current","createElement","setAttribute","parentNode","insertBefore","appendChild","childRow","tr","gridTD","gridRow","colSpan","classList","add","i","append","gridCol","el","dataColName","dataColDesc","innerHTML","cellIndex","toggle","e","parent","currentTarget","parentElement","contains","remove","nextElementSibling","isHidden","push","nextSibling","toggleAll","toggleEls","querySelectorAll","toggler","click","doTogglerScreen","forEach","childRowListener","childRows","parentRows","previousElementSibling","p","cell","after","hideMain","index","pt","row","hasAttribute","eventDispatch","flush","recalc","includes","resize","mount","ilength","shouldPing","err","console","error","tempConst","ci","Array","isArray","from","Set","concat","reverse","TypeError","processConfig","tagName","toUpperCase","lastElementChild","setToggleCell","watchResize","nativeResize","observer","togElements","addEventListener","addToggleListener","ResizeObserver","entries","target","observe","observed","element","fn","obj","resizeEvent","this","contentDocument","defaultView","start","type","data","onload","stop","removeEventListener","removeChild","watch","window","render","resetRow","node","observable","tBodies","MutationObserver","mutations","mutation","addedNodes","children","removedNodes","childList","watchMutation","destroy","container","disconnect","undefined","replaceWith","childNodes","detachRows","removeToggleListener"],"mappings":"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"}
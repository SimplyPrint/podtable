{"version":3,"file":"podtable.js","sources":["../src/podtable.js","../src/utils.js"],"sourcesContent":["import { watch, getTable } from './utils'\r\n\r\nfunction Podtable(tableEl, config = {}) {\r\n    /**\r\n     * The associated table that podtable will render\r\n     * @type HTMLTableElement\r\n     */\r\n    const table = getTable(tableEl)\r\n\r\n    /**\r\n     * This is the squishitude determinant row\r\n     * @type HTMLTableRowElement\r\n     */\r\n    let targetRow\r\n\r\n    /**\r\n     * A wrapper for the render table\r\n     * @returns HTMLElement\r\n     */\r\n    let tableContainer\r\n\r\n    /**\r\n     * Perform an health check on the passed table\r\n     * @returns void\r\n     */\r\n    healthCheck(table)\r\n\r\n    /**\r\n     * Cache container width after health check passed\r\n     */\r\n    let oldTableContainerWidth = tableContainer.clientWidth\r\n\r\n    /**\r\n     * This is store for currently hidden cells\r\n     * @type Array\r\n     */\r\n    let hiddenCells = []\r\n\r\n    /**\r\n     * Constant index of cells generated from target row\r\n     * @type Array\r\n     */\r\n    let constIndex = []\r\n\r\n    /**\r\n     * These is store for cell that wont be hidden\r\n     * @type Array\r\n     */\r\n    let keepCell = [0]\r\n\r\n    /**\r\n     * This is the podtable instance\r\n     */\r\n    let _this = this\r\n\r\n    /**\r\n     * This holds the current cell that is hidden\r\n     * @returns Number\r\n     */\r\n    _this.current\r\n\r\n    /**\r\n     * Process the config options passed\r\n     * @returns void\r\n     */\r\n    processConfig(config)\r\n\r\n    /**\r\n     * Attach event listeners for control toggle\r\n     * @returns void\r\n     */\r\n    setToggleCell(table)\r\n\r\n    /**\r\n     * Renders the table for the first instance\r\n     * @returns void\r\n     */\r\n    render()\r\n\r\n    /**\r\n     * Starts a mutation observer\r\n     * @returns void\r\n     */\r\n    ayncRedraw(table)\r\n\r\n    /**\r\n     * Set rendering target row\r\n     * @param {Boolean} passed \r\n     */\r\n    function setTargetRow(passed) {\r\n        if (passed == -1) {\r\n            targetRow = table.tHead.rows[0]\r\n        } else if (passed == true) {\r\n            targetRow =  table.tBodies[0].rows[0]\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * set the wrapper for podtable\r\n     */\r\n    function setWrapper() {\r\n        tableContainer = document.createElement('div')\r\n        tableContainer.setAttribute('id', 'podtable-container')\r\n        table.parentNode.insertBefore(tableContainer, table)\r\n        tableContainer.appendChild(table)\r\n    }\r\n\r\n    /**\r\n     * Perform health check and if it fail will throw an error\r\n     * And set the proper target row\r\n     * @param {HTMLTableElement} table \r\n     */\r\n    function healthCheck(table) {\r\n        let passed = true\r\n\r\n        if (table === null) {\r\n            throw new Error('Unable to access target HTMLTableElement')\r\n        }\r\n\r\n        if (!(table instanceof HTMLTableElement)) {\r\n            throw new Error('Element is not an HTMLTableElement')\r\n        }\r\n\r\n        if (table.tHead === null) {\r\n            throw new Error('Table should have only one THEAD')\r\n        }\r\n\r\n        if (table.tHead.rows.length <= 0) {\r\n            throw new Error('tHead doesnt contain HTMLTableRowElement')\r\n        }\r\n\r\n        if (table.tHead.rows[0].cells.length < 2) {\r\n            throw new Error('tHead HTMLTableRowElement should have atleast 2 cells')\r\n        }\r\n\r\n        if (table.tBodies.length <= 0 || table.tBodies.length > 1) {\r\n            throw new Error('Table should have only one TBODY')\r\n        }\r\n\r\n        if (table.tBodies[0].rows.length <= 0) {\r\n            passed =  -1\r\n        }\r\n\r\n        setTargetRow(passed)\r\n        setWrapper()\r\n    }\r\n\r\n    /**\r\n     * Sets the control cells CSS clasess\r\n     * @param {String} tableEl \r\n     */\r\n    function setToggleCell(table) {\r\n        table.tHead.rows[0].lastElementChild.classList.add('main-toggle')\r\n\r\n        for (let row of table.tBodies[0].rows) {\r\n            row.lastElementChild.classList.add('toggle')\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The method process the config options\r\n     * * Set cell hidden priority from the right\r\n     * * Set indexes of cells to keep\r\n     * @param {Object} config \r\n     */\r\n    function processConfig(config) {\r\n        let tempConst = []\r\n\r\n        for (let ci = 0; ci < targetRow.cells.length; ci++) {\r\n            tempConst.push(ci)\r\n        }\r\n\r\n        if (Object.prototype.hasOwnProperty.call(config, 'priority') &&\r\n            Array.isArray(config.priority) && config.priority.length > 0 ) {\r\n            constIndex = Array.from(new Set(config.priority.concat(tempConst.reverse())))\r\n        } else {\r\n            constIndex = tempConst.reverse()\r\n        }\r\n\r\n        keepCell.push(tempConst.length - 1)\r\n\r\n        if(Object.prototype.hasOwnProperty.call(config, 'keepCell')) {\r\n            if (! Array.isArray(config.keepCell)) {\r\n                throw TypeError('keep cell must be of type array') \r\n            } else {\r\n                keepCell = [...keepCell, ...config.keepCell]\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create HTMLTableRowElement element & append cell column data\r\n     * @param {HTMLCollection} cells \r\n     * @returns Element Node\r\n     */\r\n    function childRow (cells) {\r\n        let tr = document.createElement('tr')\r\n        let gridTD = document.createElement('td')\r\n        let gridRow = document.createElement('div')\r\n        \r\n        gridTD.colSpan = constIndex.length\r\n        gridRow.classList.add('child-grid-row')\r\n        tr.classList.add('child')\r\n    \r\n        for (let i = 0; i < cells.length; i++) {\r\n            gridRow.append(cells[i])\r\n        }\r\n        \r\n        gridTD.append(gridRow)\r\n        tr.append(gridTD)\r\n    \r\n        return tr\r\n    }\r\n\r\n    /**\r\n     * Create HTMLElement to append to child row\r\n     * @param {HTMLTableRowElement} el\r\n     * @returns Element Node\r\n     */\r\n    function gridCol(el) {\r\n        let gridCol = document.createElement('div')\r\n        gridCol.classList.add('child-grid-col')\r\n    \r\n        let dataColName = document.createElement('div')\r\n        let dataColDesc = document.createElement('div')\r\n        dataColName.innerHTML = table.tHead.rows[0].cells[el.cellIndex].innerHTML\r\n        dataColDesc.innerHTML = el.innerHTML\r\n    \r\n        gridCol.append(dataColName)\r\n        gridCol.append(dataColDesc)\r\n        \r\n        return gridCol\r\n    }\r\n\r\n    /**\r\n     * Toggle single child row and calculate hidden element for the row \r\n     * @param {event} event\r\n     */\r\n    function toggle(e) {\r\n        if (hiddenCells.length <= 0) { return }\r\n        \r\n        let parent = e.currentTarget.parentElement\r\n\r\n        if(parent.classList.contains('has-child')) {\r\n            parent.classList.remove('has-child')\r\n            parent.nextElementSibling.remove()\r\n        } else {\r\n            parent.classList.add('has-child')\r\n            let isHidden = []\r\n            for (let i = 0; i < parent.cells.length; i++) {\r\n                if (parent.cells[i].classList.contains('hidden')) {\r\n                    isHidden.push(gridCol(parent.cells[i]))\r\n                }\r\n            }\r\n\r\n            parent.parentNode.insertBefore(childRow(isHidden), parent.nextSibling)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handles toggle all child rows event by checking which rows \r\n     * has child to close and which rows has no child to open\r\n     * @param {event} event\r\n     */\r\n    function toggleAll(e) {\r\n        if (hiddenCells.length <= 0) { return }\r\n\r\n        let toggleEls = document.querySelectorAll('.toggle')\r\n        let toggler = e.currentTarget\r\n\r\n        if(toggler.classList.contains('expanded')) {\r\n            for (let i = 0; i < toggleEls.length; i++) {\r\n                let togsParent = toggleEls[i].parentElement\r\n                if (togsParent.classList.contains('has-child')) {\r\n                    toggleEls[i].click()\r\n                }\r\n            }\r\n            \r\n            toggler.classList.remove('expanded')\r\n        } else {\r\n            for (let i = 0; i < toggleEls.length; i++) {\r\n                let togsParent = toggleEls[i].parentElement\r\n                if (! togsParent.classList.contains('has-child')) {\r\n                    toggleEls[i].click()\r\n                }\r\n            }\r\n\r\n            toggler.classList.add('expanded')\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds click Event listener to rows with css class of \r\n     * toggle and main-toggle so as to toggle child rows\r\n     */\r\n    function addToggleListener () {\r\n        let togElements = document.querySelectorAll('.toggle')\r\n        for (let i = 0; i < togElements.length; i++) {\r\n            togElements[i].addEventListener('click', (e) => {\r\n                toggle(e)\r\n            })\r\n        }\r\n\r\n        let mainToggle = document.querySelector('.main-toggle')\r\n        mainToggle.addEventListener('click', (e) => {\r\n            toggleAll(e)\r\n        })\r\n    }\r\n\r\n    /**\r\n     * Check if there are hidden elements ands determine when to show\r\n     * child row toggle button and also clean up unused css class.\r\n     */\r\n    function doTogglerScreen () {\r\n        if(hiddenCells.length > 0) {\r\n            table.classList.add('show-toggle')\r\n        } else {\r\n            document.querySelectorAll('.has-child').forEach(el => {\r\n                el.classList.remove('has-child')\r\n            })\r\n\r\n            table.classList.remove('show-toggle')\r\n            table.tHead.rows[0].cells[table.tHead.rows[0].cells.length - 1].classList.remove('expanded')\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Check for open child rows to enable reactivity as window resizes\r\n     * then apply changes, item are remove and added every time window resize\r\n     * and its like this so as to get an updated data from the cells\r\n     * parent row child row are redrawn on each control toggle.\r\n     */\r\n    function childRowListener () {\r\n        let openChildRow = document.querySelectorAll('.child')\r\n        \r\n        if(openChildRow.length > 0) {\r\n            let openChildParent = []\r\n\r\n            for (let i = 0; i < openChildRow.length; i++) {\r\n                openChildParent.push(openChildRow[i].previousElementSibling)\r\n            }\r\n\r\n            // Iterate from parents elements down to child elements\r\n            for (let p = 0; p < openChildParent.length; p++) {\r\n                let isHidden = []\r\n                \r\n                for (let cell of openChildParent[p].cells) {\r\n                    if (cell.classList.contains('hidden')) {\r\n                        isHidden.push(gridCol(cell))\r\n                    }\r\n                }\r\n\r\n                // we will remove the existing child row and put another one with new data\r\n                // we also check if the hidden cells length > 0 before inserting a new child row\r\n                // so as to avoid empty child rows and orphaned child rows\r\n                openChildParent[p].nextElementSibling.remove()\r\n                \r\n                if(hiddenCells.length > 0) {\r\n                    openChildParent[p].after(childRow(isHidden))\r\n                }\r\n\r\n                doTogglerScreen()\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Hide cells that falls into maximum squishitude\r\n     * Dispatch event for the current hidden cells index\r\n     * @param {Number} index \r\n     */\r\n    function hideMain(index, pt = table) {\r\n        hiddenCells.push(index)\r\n\r\n        for (let row of pt.rows) {\r\n            if (!row.classList.contains('child')) {\r\n                row.cells[index].classList.add('hidden')\r\n            }\r\n        }\r\n\r\n        eventDispatch(index)\r\n    }\r\n\r\n    /**\r\n     * Here we remove the hidden class and flush the hidden cells \r\n     * array so as to restart procedure for the current viewport.\r\n     */\r\n    function flush() {\r\n        for (let i = 0; i < hiddenCells.length; i++) {\r\n            for (let row of table.rows) {\r\n                if (!row.classList.contains('child')) {\r\n                    row.cells[hiddenCells[i]].classList.remove('hidden')\r\n                }\r\n            }\r\n        }\r\n\r\n        hiddenCells = []\r\n    }\r\n\r\n    /**\r\n     * Recalculate Cells thats needs to be hidden after flushing\r\n     */\r\n    function recalc() {\r\n        flush()\r\n        \r\n        for (let i = 0; i < constIndex.length; i++) {\r\n            if (targetRow.clientWidth > tableContainer.clientWidth) {\r\n                if (!hiddenCells.includes(constIndex[i])) {\r\n                    if (!keepCell.includes(constIndex[i])) {\r\n                        hideMain(constIndex[i])\r\n                        childRowListener()\r\n                    } \r\n                }\r\n            }\r\n        }\r\n        \r\n        doTogglerScreen()\r\n    }\r\n\r\n    /**\r\n     * This method recalculate which cells to hide or show and dispatch\r\n     * and event with negative index to indicate there are no hiddenCells\r\n     */\r\n    function resize() {\r\n        recalc()\r\n        \r\n        if (hiddenCells.length <= 0) {\r\n            eventDispatch(-1)\r\n            childRowListener()\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * On page load calculate cells which  can fit into the current\r\n     * maximum squishitude: apply visibility, attach necessary listeners.\r\n     */\r\n    function mount() {\r\n        hiddenCells = []\r\n        let ilength = constIndex.length\r\n        \r\n        for (let i = 0; i < ilength; i++) {\r\n\r\n            if (targetRow.clientWidth > tableContainer.clientWidth) {\r\n                if(! hiddenCells.includes(constIndex[i])) {\r\n                    if (!keepCell.includes(constIndex[i])) {\r\n                        hideMain(constIndex[i])\r\n                    } \r\n                }\r\n            }\r\n        }\r\n        doTogglerScreen()\r\n    }\r\n\r\n    /**\r\n     * This is the resize counterpart for window resize event\r\n     * or element watcher event\r\n     * @see resize\r\n     */\r\n    function observeResize() {\r\n        recalc()\r\n        if (hiddenCells.length <= 0) {\r\n            eventDispatch(-1)\r\n            childRowListener()\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Here we will start new observer or attach resize listener base on\r\n     * client browser support for observer api and the observer api is \r\n     * meant to act as resize event for podtable and this is particularly\r\n     * useful incase of element resize without window resize.\r\n     */\r\n    function observed() {\r\n        let connected = false\r\n\r\n        // try {\r\n        //     const observer = new ResizeObserver((entries) => {\r\n        //         if (entries[0].target.clientWidth !== oldTableContainerWidth) {\r\n        //             observeResize()\r\n        //         }\r\n    \r\n        //         oldTableContainerWidth = entries[0].target.clientWidth\r\n        //     })\r\n\r\n        //     observer.observe(tableContainer)\r\n        //     connected = true\r\n        // } catch (error) {\r\n        //     connected = false\r\n        // }\r\n\r\n        return connected\r\n    }\r\n\r\n\r\n    /**\r\n     * Here we will do a mount, this will be at podtable instance\r\n     * then we will add child row event listeners after which we will\r\n     * use three ways in listening in checking for resize on podtable\r\n     * * Resize observer which doesnt work on all browser\r\n     * * A custom watcher to watch element size\r\n     * * Lastly we fallback to window resize listener.\r\n     */\r\n    function render() {\r\n        mount()\r\n        addToggleListener()\r\n\r\n        if (!observed()) {\r\n            try {\r\n                watch(tableContainer, resize).start()\r\n            } catch (err) {\r\n                window.addEventListener('resize',  () => resize()) \r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * On body rows child list mutation essential row attributes and events\r\n     * will be lost hence the need to reset attriubtes and re attach necessary \r\n     * events listeners and also redispatch cells event but only the attached method\r\n     * @param {String} tableEl \r\n     */\r\n    function ayncRedraw(table) {\r\n        let bodyNode = table.tBodies[0]\r\n\r\n        function doAttributes(node) {\r\n            node.lastElementChild.classList.add('toggle')\r\n            node.lastElementChild.addEventListener('click', (e) => toggle(e))\r\n        }\r\n\r\n        const callback = (mutationList) => {\r\n            for (const mutation of mutationList) {\r\n                if (mutation.type === 'childList' && mutation.addedNodes.length === 1) {\r\n                    if (mutation.addedNodes[0].tagName == 'TR' && !mutation.addedNodes[0].classList.contains('child')) {\r\n                        doAttributes(mutation.addedNodes[0])\r\n                        shouldPing()\r\n                    }\r\n                } else if (mutation.type === 'childList' && mutation.removedNodes.length === 1) {\r\n                    if (mutation.removedNodes[0].tagName == 'TR' &&\r\n                        !mutation.removedNodes[0].classList.contains('child') &&\r\n                        mutation.removedNodes[0].classList.contains('has-child')) {\r\n                        mutation.nextSibling.remove()\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (table.tBodies[0].rows.length <= 0) {\r\n                targetRow = table.tHead.rows[0]\r\n            } else {\r\n                targetRow = table.tBodies[0].rows[0]\r\n            }\r\n\r\n            flush()\r\n            mount()\r\n        }\r\n\r\n        const observer = new MutationObserver(callback)\r\n        observer.observe(bodyNode, { childList: true })\r\n    }\r\n\r\n    /**\r\n     * For every cells hidden this method will be called which check\r\n     * if events want to be received also attach hidden index to return object.\r\n     * @param {Number} index \r\n     */\r\n    function eventDispatch(index) {\r\n        _this.current = index\r\n\r\n        if (config.event) { shouldPing() }\r\n    }\r\n\r\n    /**\r\n     * Call the user attached method only if the event key is in the config \r\n     * object and it is set to true and we will  also wrap the function call \r\n     * in a try catch block to avoid code execution failure.\r\n     */\r\n    function shouldPing() {\r\n        if (config.event) {\r\n            try {\r\n                config.method(_this)\r\n            } catch (error) {\r\n                console.error(error)\r\n            }\r\n        }\r\n    }\r\n\r\n    if (config.event) { return _this }\r\n}\r\n\r\nexport default Podtable","function watch(element, fn) {\r\n    let _this = {}\r\n    let obj = document.createElement('object')\r\n\r\n    /**\r\n     * Event listener to the docs object\r\n     */\r\n    function resizeEvent () {\r\n        this.contentDocument.defaultView.addEventListener('resize', fn)\r\n    }\r\n\r\n    /**\r\n     * Attach event listener to object\r\n     */\r\n    _this.start = () => {\r\n        obj.classList.add('pt-object')\r\n        obj.type = 'text/html'\r\n        obj.data = 'about:blank'\r\n        obj.onload = resizeEvent\r\n        element.appendChild(obj)\r\n    }\r\n\r\n    /**\r\n     * dettach event listener and removw object\r\n     */\r\n    _this.stop = () => {\r\n        obj.contentDocument.defaultView.removeEventListener('resize', fn)\r\n        element.removeChild(obj)\r\n    }\r\n\r\n    return _this\r\n}\r\n\r\n/**\r\n * Returns the target table element\r\n * @param {String|HTMLTableElement} tableEl \r\n * @returns HTMLTableElement\r\n */\r\nfunction getTable(tableEl) {\r\n    if (typeof tableEl === 'string' || tableEl instanceof String) {\r\n        return document.querySelector(tableEl)\r\n    } else {\r\n        return tableEl\r\n    }\r\n}\r\n\r\nexport {\r\n    watch,\r\n    getTable\r\n}"],"names":["tableEl","config","targetRow","tableContainer","table","String","document","querySelector","getTable","passed","Error","HTMLTableElement","tHead","rows","length","cells","tBodies","setTargetRow","setWrapper","healthCheck","hiddenCells","constIndex","keepCell","_this","this","createElement","setAttribute","parentNode","insertBefore","appendChild","childRow","tr","gridTD","gridRow","colSpan","classList","add","i","append","gridCol","el","dataColName","dataColDesc","innerHTML","cellIndex","toggle","e","parent","currentTarget","parentElement","contains","remove","nextElementSibling","isHidden","push","nextSibling","doTogglerScreen","querySelectorAll","forEach","childRowListener","openChildRow","openChildParent","previousElementSibling","p","cell","after","hideMain","index","pt","row","eventDispatch","flush","resize","clientWidth","includes","recalc","mount","ilength","current","event","shouldPing","method","error","console","tempConst","ci","Object","prototype","hasOwnProperty","call","Array","isArray","priority","from","Set","concat","reverse","TypeError","processConfig","lastElementChild","setToggleCell","togElements","addEventListener","toggleEls","toggler","click","toggleAll","addToggleListener","element","fn","obj","resizeEvent","contentDocument","defaultView","start","type","data","onload","stop","removeEventListener","removeChild","watch","err","window","render","bodyNode","MutationObserver","mutationList","mutation","addedNodes","tagName","node","removedNodes","observe","childList","ayncRedraw"],"mappings":"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"}